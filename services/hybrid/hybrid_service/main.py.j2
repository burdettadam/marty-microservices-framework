"""
{{service_description}}

This is a hybrid service generated from the Marty Enterprise Microservices Framework.
It provides both FastAPI (HTTP/REST) and gRPC interfaces using enterprise patterns with unified observability:
- Enterprise service configuration and dependency injection
- Unified OpenTelemetry observability with distributed tracing and monitoring
- Enhanced correlation ID tracking across both HTTP and gRPC interfaces
- Event-driven architecture with transactional outbox pattern
- Database management with repositories and Unit of Work
- Service discovery and health checking
- Comprehensive testing infrastructure
"""

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import AsyncGenerator

import uvicorn
from fastapi import FastAPI

from marty_msf.framework.grpc import UnifiedGrpcServer, ServiceDefinition, create_grpc_server
from src.framework.database import DatabaseManager
from src.framework.events import EventBus, InMemoryEventBus
from src.framework.observability.monitoring import ServiceMonitor
from src.framework.config import get_service_config, config_manager

# Enhanced unified observability imports
from marty_msf.observability.standard import create_standard_observability, set_global_observability
from marty_msf.observability.standard_correlation import (
    StandardCorrelationMiddleware,
    StandardCorrelationInterceptor,
    CorrelationContext
)

# Legacy observability imports - fail if not available
from src.framework.observability.tracing import init_tracing, traced_operation


from src.{{service_package}}.app.api.routes import router
from src.{{service_package}}.app.core.middleware import setup_middleware
from src.{{service_package}}.app.core.error_handlers import setup_error_handlers
from src.{{service_package}}.config import get_config

logger = logging.getLogger(__name__)

# Global observability instance
observability = None


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Manage application lifespan with enterprise infrastructure and unified observability."""
    global observability

    # Get configuration
    config = get_config()

    logger.info("{{service_name}} starting with unified observability")

    # Initialize enhanced unified observability
    observability = create_standard_observability(
        service_name="{{service_name}}",
        service_version="1.0.0",
        service_type="hybrid"
    )
    await observability.initialize()
    set_global_observability(observability)
    logger.info("Enhanced unified observability initialized")

    # Initialize database
    database = DatabaseManager(config["DATABASE_URL"])
    await database.initialize()
    app.state.database = database

    # Initialize event bus
    event_bus: EventBus = InMemoryEventBus()
    await event_bus.start()
    app.state.event_bus = event_bus

    # Initialize monitoring
    monitor = ServiceMonitor("{{service_name}}")
    await monitor.start()
    app.state.monitor = monitor

    logger.info("{{service_name}} FastAPI application started")

    yield

    # Cleanup
    await monitor.stop()
    await event_bus.stop()
    await database.cleanup()

    # Cleanup observability
    if observability:
        await observability.shutdown()

    logger.info("{{service_name}} FastAPI application stopped")


def create_fastapi_app() -> FastAPI:
    """
    Create FastAPI application with enterprise patterns and unified observability.

    Returns:
        Configured FastAPI application with enterprise infrastructure
    """
    # Get service configuration
    config = get_config()

    # Initialize FastAPI with enterprise configuration
    app = FastAPI(
        title="{{service_description}}",
        version="1.0.0",
        debug=config.get("DEBUG", False),
        docs_url="/docs" if config.get("DOCS_ENABLED", True) else None,
        lifespan=lifespan,
    )

    # Add unified observability middleware
    app.add_middleware(StandardCorrelationMiddleware)

    # Setup enterprise patterns
    setup_middleware(app, config)
    setup_error_handlers(app)

    # Include API routes
    app.include_router(router, prefix="/api/v1")

    return app


async def run_fastapi_server() -> None:
    """Run the FastAPI server with Ultra-DRY configuration."""
    service_config = get_service_config("{{service_name}}", "hybrid")

    app = create_fastapi_app()

    # Create uvicorn config using DRY service configuration
    uvicorn_config = uvicorn.Config(
        app,
        host=service_config.get("api_host", "127.0.0.1"),
        port=service_config.get("api_port", 8000),
        log_level=service_config.get("log_level", "info").lower(),
        reload=service_config.get("debug", False),
    )

    # Run server
    server = uvicorn.Server(uvicorn_config)
    await server.serve()


async def run_grpc_server() -> None:
    """Run the gRPC server using UnifiedGrpcServer with unified observability."""
    logger.info("Starting {{service_name}} gRPC server using UnifiedGrpcServer")

    service_config = get_service_config("{{service_name}}", "hybrid")

    # Create the unified gRPC server
    grpc_server = create_grpc_server(
        port=service_config.get("grpc_port", 50051),
        interceptors=[StandardCorrelationInterceptor()],
        enable_health_service=True,
        max_workers=service_config.get("grpc_max_workers", 10),
        enable_reflection=service_config.get("grpc_reflection", True)
    )

    # Import and register service
    from src.{{service_package}}.app.services.{{service_package}}_grpc_service import {{service_name|title}}Service

    service_definition = ServiceDefinition(
        service_class={{service_name|title}}Service,
        service_name="{{service_name}}",
        priority=1
    )

    await grpc_server.register_service(service_definition)

    # Start the server
    await grpc_server.start()

    try:
        await grpc_server.wait_for_termination()
    finally:
        await grpc_server.stop(grace=30)


async def main() -> None:
    """
    Run both FastAPI and gRPC servers concurrently using Ultra-DRY patterns with unified observability.

    This provides both HTTP/REST and gRPC interfaces for the service,
    sharing the same business logic, Ultra-DRY configuration, and observability infrastructure.
    """
    service_config = get_service_config("{{service_name}}", "hybrid")

    logger.info("Starting {{service_name}} hybrid service")
    logger.info("All observability features enabled")

    if service_config.get("concurrent_servers", True):
        # Run both servers concurrently
        await asyncio.gather(
            run_fastapi_server(),
            run_grpc_server(),
        )
    else:
        # Run servers sequentially (for debugging)
        await run_fastapi_server()


if __name__ == "__main__":
    asyncio.run(main())
