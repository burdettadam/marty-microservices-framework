"""
{{service_name}} Authentication Service Configuration using unified configuration system.
"""

from typing import List, Optional, Dict, Any
from datetime import timedelta

from marty_msf.framework.config import UnifiedConfigurationManager
from marty_msf.framework.secrets import UnifiedSecrets


async def get_auth_service_config(
    config_manager: Optional[UnifiedConfigurationManager] = None,
    secrets_manager: Optional[UnifiedSecrets] = None
) -> Dict[str, Any]:
    """
    Get authentication service configuration using unified configuration and secrets.

    Args:
        config_manager: Optional existing configuration manager instance
        secrets_manager: Optional existing secrets manager instance

    Returns:
        Dictionary with authentication service configuration
    """
    if config_manager is None:
        config_manager = UnifiedConfigurationManager()
        await config_manager.initialize()

    if secrets_manager is None:
        secrets_manager = UnifiedSecrets()
        await secrets_manager.initialize()

    # JWT Configuration
    jwt_secret_key = await secrets_manager.get_secret("jwt_secret_key",
                                                     config_manager.get("auth.jwt.secret_key", "your-secret-key-change-in-production"))

    # OAuth2 Secrets
    oauth2_google_client_secret = await secrets_manager.get_secret("oauth2_google_client_secret",
                                                                  config_manager.get("auth.oauth2.google.client_secret"))
    oauth2_github_client_secret = await secrets_manager.get_secret("oauth2_github_client_secret",
                                                                  config_manager.get("auth.oauth2.github.client_secret"))
    oauth2_microsoft_client_secret = await secrets_manager.get_secret("oauth2_microsoft_client_secret",
                                                                     config_manager.get("auth.oauth2.microsoft.client_secret"))

    # Database secrets
    database_url = await secrets_manager.get_secret("auth_database_url",
                                                   config_manager.get("auth.database.url", "postgresql://localhost:5432/{{service_package}}_auth_db"))

    # Redis secrets
    redis_url = await secrets_manager.get_secret("auth_redis_url",
                                                config_manager.get("auth.redis.url", "redis://localhost:6379/1"))

    return {
        # Service metadata
        "service_name": config_manager.get("service.name", "{{service_name}}"),
        "service_version": config_manager.get("service.version", "1.0.0"),

        # JWT Configuration
        "jwt_secret_key": jwt_secret_key,
        "jwt_algorithm": config_manager.get("auth.jwt.algorithm", "HS256"),
        "jwt_access_token_expire_minutes": config_manager.get("auth.jwt.access_token_expire_minutes", 30),
        "jwt_refresh_token_expire_days": config_manager.get("auth.jwt.refresh_token_expire_days", 7),
        "jwt_issuer": config_manager.get("auth.jwt.issuer", "{{service_package}}-auth"),
        "jwt_audience": config_manager.get("auth.jwt.audience", "{{service_package}}-api"),

        # OAuth2 Configuration
        "oauth2_enabled": config_manager.get("auth.oauth2.enabled", False),
        "oauth2_google_client_id": config_manager.get("auth.oauth2.google.client_id"),
        "oauth2_google_client_secret": oauth2_google_client_secret,
        "oauth2_github_client_id": config_manager.get("auth.oauth2.github.client_id"),
        "oauth2_github_client_secret": oauth2_github_client_secret,
        "oauth2_microsoft_client_id": config_manager.get("auth.oauth2.microsoft.client_id"),
        "oauth2_microsoft_client_secret": oauth2_microsoft_client_secret,

        # RBAC Configuration
        "rbac_enabled": config_manager.get("auth.rbac.enabled", True),
        "rbac_default_role": config_manager.get("auth.rbac.default_role", "user"),
        "rbac_admin_emails": config_manager.get("auth.rbac.admin_emails", []),
        "rbac_cache_ttl_seconds": config_manager.get("auth.rbac.cache_ttl_seconds", 300),

        # Database Configuration
        "database_url": database_url,
        "database_pool_size": config_manager.get("auth.database.pool_size", 10),
        "database_max_overflow": config_manager.get("auth.database.max_overflow", 20),
        "database_pool_timeout": config_manager.get("auth.database.pool_timeout", 30),
        "database_pool_recycle": config_manager.get("auth.database.pool_recycle", 3600),
        "database_echo": config_manager.get("auth.database.echo", False),

        # Redis Configuration
        "redis_url": redis_url,
        "redis_pool_size": config_manager.get("auth.redis.pool_size", 10),
        "redis_session_expire_seconds": config_manager.get("auth.redis.session_expire_seconds", 3600),
        "redis_cache_expire_seconds": config_manager.get("auth.redis.cache_expire_seconds", 300),
    }

    # Security Configuration
    password_hash_algorithm: str = os.environ.get("PASSWORD_HASH_ALGORITHM", "bcrypt")
    password_hash_rounds: int = int(os.environ.get("PASSWORD_HASH_ROUNDS", "12"))
    password_min_length: int = int(os.environ.get("PASSWORD_MIN_LENGTH", "8"))
    password_require_uppercase: bool = os.environ.get("PASSWORD_REQUIRE_UPPERCASE", "true").lower() == "true"
    password_require_lowercase: bool = os.environ.get("PASSWORD_REQUIRE_LOWERCASE", "true").lower() == "true"
    password_require_digits: bool = os.environ.get("PASSWORD_REQUIRE_DIGITS", "true").lower() == "true"
    password_require_special: bool = os.environ.get("PASSWORD_REQUIRE_SPECIAL", "true").lower() == "true"

    # Session Configuration
    session_cookie_name: str = os.environ.get("SESSION_COOKIE_NAME", "{{service_package}}_session")
    session_cookie_secure: bool = os.environ.get("SESSION_COOKIE_SECURE", "true").lower() == "true"
    session_cookie_httponly: bool = os.environ.get("SESSION_COOKIE_HTTPONLY", "true").lower() == "true"
    session_cookie_samesite: str = os.environ.get("SESSION_COOKIE_SAMESITE", "lax")
    session_max_age_seconds: int = int(os.environ.get("SESSION_MAX_AGE_SECONDS", "86400"))  # 24 hours

    # Multi-Factor Authentication
    mfa_enabled: bool = os.environ.get("MFA_ENABLED", "false").lower() == "true"
    mfa_issuer_name: str = os.environ.get("MFA_ISSUER_NAME", "{{service_name}}")
    mfa_totp_window: int = int(os.environ.get("MFA_TOTP_WINDOW", "1"))
    mfa_backup_codes_count: int = int(os.environ.get("MFA_BACKUP_CODES_COUNT", "10"))

    # Rate Limiting
    rate_limit_enabled: bool = os.environ.get("RATE_LIMIT_ENABLED", "true").lower() == "true"
    rate_limit_requests_per_minute: int = int(os.environ.get("RATE_LIMIT_REQUESTS_PER_MINUTE", "60"))
    rate_limit_burst_size: int = int(os.environ.get("RATE_LIMIT_BURST_SIZE", "10"))
    rate_limit_window_seconds: int = int(os.environ.get("RATE_LIMIT_WINDOW_SECONDS", "60"))

    # Service-to-Service Authentication
    service_auth_enabled: bool = os.environ.get("SERVICE_AUTH_ENABLED", "true").lower() == "true"
    service_auth_secret: str = os.environ.get("SERVICE_AUTH_SECRET", "service-secret-change-in-production")
    service_auth_token_expire_minutes: int = int(os.environ.get("SERVICE_AUTH_TOKEN_EXPIRE_MINUTES", "60"))
    trusted_services: List[str] = os.environ.get("TRUSTED_SERVICES", "").split(",") if os.environ.get("TRUSTED_SERVICES") else []

    # External Identity Providers
    external_providers_enabled: bool = os.environ.get("EXTERNAL_PROVIDERS_ENABLED", "false").lower() == "true"
    ldap_enabled: bool = os.environ.get("LDAP_ENABLED", "false").lower() == "true"
    ldap_server: Optional[str] = os.environ.get("LDAP_SERVER")
    ldap_port: int = int(os.environ.get("LDAP_PORT", "389"))
    ldap_use_ssl: bool = os.environ.get("LDAP_USE_SSL", "false").lower() == "true"
    ldap_bind_dn: Optional[str] = os.environ.get("LDAP_BIND_DN")
    ldap_bind_password: Optional[str] = os.environ.get("LDAP_BIND_PASSWORD")
    ldap_user_search_base: Optional[str] = os.environ.get("LDAP_USER_SEARCH_BASE")
    ldap_user_search_filter: str = os.environ.get("LDAP_USER_SEARCH_FILTER", "(uid={username})")

    # Audit and Logging
    audit_enabled: bool = os.environ.get("AUDIT_ENABLED", "true").lower() == "true"
    audit_log_failed_attempts: bool = os.environ.get("AUDIT_LOG_FAILED_ATTEMPTS", "true").lower() == "true"
    audit_log_successful_logins: bool = os.environ.get("AUDIT_LOG_SUCCESSFUL_LOGINS", "true").lower() == "true"
    audit_log_password_changes: bool = os.environ.get("AUDIT_LOG_PASSWORD_CHANGES", "true").lower() == "true"
    audit_log_role_changes: bool = os.environ.get("AUDIT_LOG_ROLE_CHANGES", "true").lower() == "true"

    # Account Security
    account_lockout_enabled: bool = os.environ.get("ACCOUNT_LOCKOUT_ENABLED", "true").lower() == "true"
    account_lockout_attempts: int = int(os.environ.get("ACCOUNT_LOCKOUT_ATTEMPTS", "5"))
    account_lockout_duration_minutes: int = int(os.environ.get("ACCOUNT_LOCKOUT_DURATION_MINUTES", "15"))
    account_lockout_window_minutes: int = int(os.environ.get("ACCOUNT_LOCKOUT_WINDOW_MINUTES", "15"))

    # Email Configuration (for password reset, etc.)
    email_enabled: bool = os.environ.get("EMAIL_ENABLED", "false").lower() == "true"
    email_smtp_server: Optional[str] = os.environ.get("EMAIL_SMTP_SERVER")
    email_smtp_port: int = int(os.environ.get("EMAIL_SMTP_PORT", "587"))
    email_smtp_username: Optional[str] = os.environ.get("EMAIL_SMTP_USERNAME")
    email_smtp_password: Optional[str] = os.environ.get("EMAIL_SMTP_PASSWORD")
    email_use_tls: bool = os.environ.get("EMAIL_USE_TLS", "true").lower() == "true"
    email_from_address: str = os.environ.get("EMAIL_FROM_ADDRESS", "noreply@{{service_package}}.com")

    # Token Validation
    token_validation_strict: bool = os.environ.get("TOKEN_VALIDATION_STRICT", "true").lower() == "true"
    token_validation_leeway_seconds: int = int(os.environ.get("TOKEN_VALIDATION_LEEWAY_SECONDS", "30"))
    token_blacklist_enabled: bool = os.environ.get("TOKEN_BLACKLIST_ENABLED", "true").lower() == "true"

    # CORS Configuration
    cors_origins: List[str] = os.environ.get("CORS_ORIGINS", "*").split(",")
    cors_allow_credentials: bool = os.environ.get("CORS_ALLOW_CREDENTIALS", "true").lower() == "true"
    cors_allow_methods: List[str] = os.environ.get("CORS_ALLOW_METHODS", "GET,POST,PUT,DELETE,OPTIONS").split(",")
    cors_allow_headers: List[str] = os.environ.get("CORS_ALLOW_HEADERS", "Content-Type,Authorization").split(",")

    @property
    def jwt_access_token_expire_delta(self) -> timedelta:
        """Get JWT access token expiration as timedelta."""
        return timedelta(minutes=self.jwt_access_token_expire_minutes)

    @property
    def jwt_refresh_token_expire_delta(self) -> timedelta:
        """Get JWT refresh token expiration as timedelta."""
        return timedelta(days=self.jwt_refresh_token_expire_days)

    @property
    def session_max_age_delta(self) -> timedelta:
        """Get session max age as timedelta."""
        return timedelta(seconds=self.session_max_age_seconds)

    @property
    def account_lockout_duration_delta(self) -> timedelta:
        """Get account lockout duration as timedelta."""
        return timedelta(minutes=self.account_lockout_duration_minutes)

    @property
    def account_lockout_window_delta(self) -> timedelta:
        """Get account lockout window as timedelta."""
        return timedelta(minutes=self.account_lockout_window_minutes)

    def get_oauth2_config(self, provider: str) -> Dict[str, Any]:
        """Get OAuth2 configuration for a specific provider."""
        configs = {
            "google": {
                "client_id": self.oauth2_google_client_id,
                "client_secret": self.oauth2_google_client_secret,
                "auth_url": "https://accounts.google.com/o/oauth2/auth",
                "token_url": "https://oauth2.googleapis.com/token",
                "userinfo_url": "https://www.googleapis.com/oauth2/v2/userinfo",
                "scopes": ["openid", "email", "profile"]
            },
            "github": {
                "client_id": self.oauth2_github_client_id,
                "client_secret": self.oauth2_github_client_secret,
                "auth_url": "https://github.com/login/oauth/authorize",
                "token_url": "https://github.com/login/oauth/access_token",
                "userinfo_url": "https://api.github.com/user",
                "scopes": ["user:email"]
            },
            "microsoft": {
                "client_id": self.oauth2_microsoft_client_id,
                "client_secret": self.oauth2_microsoft_client_secret,
                "auth_url": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
                "token_url": "https://login.microsoftonline.com/common/oauth2/v2.0/token",
                "userinfo_url": "https://graph.microsoft.com/v1.0/me",
                "scopes": ["openid", "email", "profile"]
            }
        }
        return configs.get(provider, {})

    def validate_config(self) -> None:
        """Validate the configuration."""
        if self.jwt_secret_key == "your-secret-key-change-in-production":
            raise ValueError("JWT secret key must be changed in production")

        if self.service_auth_secret == "service-secret-change-in-production":
            raise ValueError("Service auth secret must be changed in production")

        if self.oauth2_enabled:
            if not any([
                self.oauth2_google_client_id,
                self.oauth2_github_client_id,
                self.oauth2_microsoft_client_id
            ]):
                raise ValueError("At least one OAuth2 provider must be configured when OAuth2 is enabled")

        if self.ldap_enabled:
            if not all([self.ldap_server, self.ldap_bind_dn, self.ldap_user_search_base]):
                raise ValueError("LDAP server, bind DN, and user search base must be configured when LDAP is enabled")

        if self.email_enabled:
            if not all([self.email_smtp_server, self.email_smtp_username, self.email_smtp_password]):
                raise ValueError("SMTP configuration must be complete when email is enabled")
