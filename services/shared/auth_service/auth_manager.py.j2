"""
Authentication Manager for {{service_name}}
"""

import bcrypt
import secrets
import pyotp
import qrcode
import io
import base64
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, List, Tuple
import logging

from src.{{service_package}}.app.core.config import {{service_class}}ServiceConfig
from src.{{service_package}}.app.core.models import User, UserSession, AuthAuditLog, ExternalAccount
from src.{{service_package}}.app.repositories import (
    get_user_repository,
    get_session_repository,
    get_audit_repository,
    get_external_account_repository
)
from src.{{service_package}}.app.core.token_manager import get_token_manager

logger = logging.getLogger(__name__)


class AuthenticationError(Exception):
    """Base exception for authentication errors."""
    pass


class InvalidCredentialsError(AuthenticationError):
    """Raised when credentials are invalid."""
    pass


class AccountLockedError(AuthenticationError):
    """Raised when account is locked."""
    pass


class MFARequiredError(AuthenticationError):
    """Raised when MFA verification is required."""
    pass


class AuthManager:
    """Manages user authentication, password verification, and MFA."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the authentication manager."""
        self.config = config
        self.user_repo = get_user_repository()
        self.session_repo = get_session_repository()
        self.audit_repo = get_audit_repository()
        self.external_repo = get_external_account_repository()
        self.token_manager = get_token_manager()

    async def initialize(self) -> None:
        """Initialize the authentication manager."""
        logger.info("Authentication manager initialized")

    def hash_password(self, password: str) -> str:
        """Hash a password using bcrypt.

        Args:
            password: Plain text password

        Returns:
            Hashed password string
        """
        if self.config.password_hash_algorithm != "bcrypt":
            raise ValueError(f"Unsupported hash algorithm: {self.config.password_hash_algorithm}")

        salt = bcrypt.gensalt(rounds=self.config.password_hash_rounds)
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')

    def verify_password(self, password: str, hashed_password: str) -> bool:
        """Verify a password against its hash.

        Args:
            password: Plain text password
            hashed_password: Hashed password to verify against

        Returns:
            True if password matches
        """
        try:
            return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))
        except Exception as e:
            logger.error(f"Error verifying password: {e}")
            return False

    def validate_password_strength(self, password: str) -> Tuple[bool, List[str]]:
        """Validate password strength according to policy.

        Args:
            password: Password to validate

        Returns:
            Tuple of (is_valid, list_of_errors)
        """
        errors = []

        if len(password) < self.config.password_min_length:
            errors.append(f"Password must be at least {self.config.password_min_length} characters long")

        if self.config.password_require_uppercase and not any(c.isupper() for c in password):
            errors.append("Password must contain at least one uppercase letter")

        if self.config.password_require_lowercase and not any(c.islower() for c in password):
            errors.append("Password must contain at least one lowercase letter")

        if self.config.password_require_digits and not any(c.isdigit() for c in password):
            errors.append("Password must contain at least one digit")

        if self.config.password_require_special and not any(c in "!@#$%^&*()_+-=[]{}|;:,.<>?" for c in password):
            errors.append("Password must contain at least one special character")

        return len(errors) == 0, errors

    async def authenticate_user(
        self,
        session,
        username_or_email: str,
        password: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        require_mfa: bool = True
    ) -> Tuple[Optional[User], Dict[str, Any]]:
        """Authenticate a user with username/email and password.

        Args:
            session: Database session
            username_or_email: Username or email address
            password: Plain text password
            ip_address: Client IP address
            user_agent: Client user agent
            require_mfa: Whether to require MFA verification

        Returns:
            Tuple of (User object if authenticated, auth_result dict)

        Raises:
            InvalidCredentialsError: If credentials are invalid
            AccountLockedError: If account is locked
            MFARequiredError: If MFA is required but not provided
        """
        auth_result = {
            "success": False,
            "user_id": None,
            "mfa_required": False,
            "mfa_methods": [],
            "session_id": None,
            "message": ""
        }

        try:
            # Find user by username or email
            user = self.user_repo.get_by_username_or_email(session, username_or_email)

            if not user:
                # Log failed attempt
                self.audit_repo.log_auth_event(
                    session=session,
                    event_type="login_failed",
                    event_category="authentication",
                    success=False,
                    username=username_or_email,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    error_message="User not found"
                )
                raise InvalidCredentialsError("Invalid username or password")

            # Check if account is locked
            if user.is_locked():
                self.audit_repo.log_auth_event(
                    session=session,
                    event_type="login_blocked",
                    event_category="security",
                    success=False,
                    user_id=user.id,
                    username=user.username,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    error_message="Account locked"
                )
                raise AccountLockedError(f"Account locked until {user.locked_until}")

            # Check if user can login
            if not user.can_login():
                self.audit_repo.log_auth_event(
                    session=session,
                    event_type="login_blocked",
                    event_category="security",
                    success=False,
                    user_id=user.id,
                    username=user.username,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    error_message=f"Account status: {user.status}, Email verified: {user.email_verified}"
                )
                raise InvalidCredentialsError("Account not available for login")

            # Verify password
            if not user.password_hash or not self.verify_password(password, user.password_hash):
                # Increment failed attempts
                self.user_repo.increment_failed_attempts(session, user.id)

                # Check if we should lock the account
                if self.config.account_lockout_enabled and user.failed_login_attempts >= self.config.account_lockout_attempts:
                    lock_until = datetime.now(timezone.utc) + self.config.account_lockout_duration_delta
                    self.user_repo.lock_account(session, user.id, lock_until)

                    self.audit_repo.log_auth_event(
                        session=session,
                        event_type="account_locked",
                        event_category="security",
                        success=False,
                        user_id=user.id,
                        username=user.username,
                        ip_address=ip_address,
                        user_agent=user_agent,
                        details={"lock_until": lock_until.isoformat(), "failed_attempts": user.failed_login_attempts}
                    )

                self.audit_repo.log_auth_event(
                    session=session,
                    event_type="login_failed",
                    event_category="authentication",
                    success=False,
                    user_id=user.id,
                    username=user.username,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    error_message="Invalid password"
                )
                raise InvalidCredentialsError("Invalid username or password")

            # Reset failed attempts on successful password verification
            if user.failed_login_attempts > 0:
                self.user_repo.reset_failed_attempts(session, user.id)

            # Check if MFA is required
            if require_mfa and user.mfa_enabled:
                auth_result.update({
                    "mfa_required": True,
                    "mfa_methods": ["totp"],
                    "user_id": str(user.id),
                    "message": "MFA verification required"
                })

                if user.mfa_backup_codes:
                    auth_result["mfa_methods"].append("backup_code")

                # Log partial success
                self.audit_repo.log_auth_event(
                    session=session,
                    event_type="login_partial",
                    event_category="authentication",
                    success=True,
                    user_id=user.id,
                    username=user.username,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    details={"mfa_required": True}
                )

                raise MFARequiredError("MFA verification required")

            # Update last login
            self.user_repo.update_last_login(session, user.id, ip_address)

            # Log successful login
            self.audit_repo.log_auth_event(
                session=session,
                event_type="login_success",
                event_category="authentication",
                success=True,
                user_id=user.id,
                username=user.username,
                ip_address=ip_address,
                user_agent=user_agent
            )

            auth_result.update({
                "success": True,
                "user_id": str(user.id),
                "message": "Authentication successful"
            })

            return user, auth_result

        except (InvalidCredentialsError, AccountLockedError, MFARequiredError):
            raise
        except Exception as e:
            logger.error(f"Error during authentication: {e}")
            self.audit_repo.log_auth_event(
                session=session,
                event_type="login_error",
                event_category="system",
                success=False,
                username=username_or_email,
                ip_address=ip_address,
                user_agent=user_agent,
                error_message=str(e)
            )
            raise AuthenticationError("Authentication system error")

    def verify_mfa_totp(self, user: User, totp_code: str) -> bool:
        """Verify TOTP code for MFA.

        Args:
            user: User object with MFA enabled
            totp_code: 6-digit TOTP code

        Returns:
            True if TOTP code is valid
        """
        if not user.mfa_enabled or not user.mfa_secret:
            return False

        try:
            totp = pyotp.TOTP(user.mfa_secret)
            return totp.verify(totp_code, valid_window=self.config.mfa_totp_window)
        except Exception as e:
            logger.error(f"Error verifying TOTP: {e}")
            return False

    def verify_mfa_backup_code(self, session, user: User, backup_code: str) -> bool:
        """Verify backup code for MFA.

        Args:
            session: Database session
            user: User object with MFA enabled
            backup_code: Backup code to verify

        Returns:
            True if backup code is valid and unused
        """
        if not user.mfa_enabled or not user.mfa_backup_codes:
            return False

        # Check if code exists and is unused
        backup_codes = user.mfa_backup_codes
        if backup_code in backup_codes:
            # Remove the used code
            backup_codes.remove(backup_code)
            self.user_repo.update_mfa_backup_codes(session, user.id, backup_codes)

            logger.info(f"Backup code used for user {user.username}")
            return True

        return False

    def setup_mfa(self, session, user: User) -> Dict[str, Any]:
        """Set up MFA for a user.

        Args:
            session: Database session
            user: User object

        Returns:
            Dictionary with MFA setup information
        """
        # Generate TOTP secret
        secret = pyotp.random_base32()

        # Generate QR code
        totp = pyotp.TOTP(secret)
        provisioning_uri = totp.provisioning_uri(
            name=user.email,
            issuer_name=self.config.mfa_issuer_name
        )

        # Create QR code image
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(provisioning_uri)
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")
        img_buffer = io.BytesIO()
        img.save(img_buffer, format='PNG')
        img_data = base64.b64encode(img_buffer.getvalue()).decode()

        # Generate backup codes
        backup_codes = [secrets.token_hex(8) for _ in range(self.config.mfa_backup_codes_count)]

        # Save MFA settings (but don't enable yet)
        self.user_repo.setup_mfa(session, user.id, secret, backup_codes)

        return {
            "secret": secret,
            "qr_code": f"data:image/png;base64,{img_data}",
            "provisioning_uri": provisioning_uri,
            "backup_codes": backup_codes
        }

    def enable_mfa(self, session, user: User, totp_code: str) -> bool:
        """Enable MFA for a user after verifying setup.

        Args:
            session: Database session
            user: User object
            totp_code: TOTP code to verify setup

        Returns:
            True if MFA was enabled successfully
        """
        # Verify the TOTP code with the new secret
        if self.verify_mfa_totp(user, totp_code):
            self.user_repo.enable_mfa(session, user.id)

            self.audit_repo.log_auth_event(
                session=session,
                event_type="mfa_enabled",
                event_category="security",
                success=True,
                user_id=user.id,
                username=user.username
            )

            logger.info(f"MFA enabled for user {user.username}")
            return True

        return False

    def disable_mfa(self, session, user: User, password: str) -> bool:
        """Disable MFA for a user.

        Args:
            session: Database session
            user: User object
            password: User's current password for verification

        Returns:
            True if MFA was disabled successfully
        """
        # Verify password
        if not self.verify_password(password, user.password_hash):
            return False

        self.user_repo.disable_mfa(session, user.id)

        self.audit_repo.log_auth_event(
            session=session,
            event_type="mfa_disabled",
            event_category="security",
            success=True,
            user_id=user.id,
            username=user.username
        )

        logger.info(f"MFA disabled for user {user.username}")
        return True

    def create_user_session(
        self,
        session,
        user: User,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        device_info: Optional[Dict[str, Any]] = None
    ) -> UserSession:
        """Create a new user session.

        Args:
            session: Database session
            user: User object
            ip_address: Client IP address
            user_agent: Client user agent
            device_info: Device information

        Returns:
            UserSession object
        """
        session_token = secrets.token_urlsafe(32)
        refresh_token = secrets.token_urlsafe(32)
        expires_at = datetime.now(timezone.utc) + self.config.session_max_age_delta

        user_session = self.session_repo.create(
            session=session,
            user_id=user.id,
            session_token=session_token,
            refresh_token=refresh_token,
            expires_at=expires_at,
            ip_address=ip_address,
            user_agent=user_agent,
            device_info=device_info
        )

        logger.debug(f"Created session for user {user.username}")
        return user_session

    def validate_session(self, session, session_token: str) -> Optional[UserSession]:
        """Validate a user session.

        Args:
            session: Database session
            session_token: Session token to validate

        Returns:
            UserSession object if valid, None otherwise
        """
        user_session = self.session_repo.get_by_token(session, session_token)

        if user_session and user_session.is_active():
            # Update last activity
            self.session_repo.update_activity(session, user_session.id)
            return user_session

        return None

    def revoke_session(self, session, session_id: str, reason: str = "user_logout") -> bool:
        """Revoke a user session.

        Args:
            session: Database session
            session_id: Session ID to revoke
            reason: Reason for revocation

        Returns:
            True if session was revoked
        """
        return self.session_repo.revoke(session, session_id, reason)

    def revoke_all_user_sessions(
        self,
        session,
        user_id: str,
        except_session_id: Optional[str] = None,
        reason: str = "security_revoke"
    ) -> int:
        """Revoke all sessions for a user.

        Args:
            session: Database session
            user_id: User ID whose sessions to revoke
            except_session_id: Session ID to exclude from revocation
            reason: Reason for revocation

        Returns:
            Number of sessions revoked
        """
        return self.session_repo.revoke_user_sessions(
            session, user_id, except_session_id, reason
        )

    def change_password(
        self,
        session,
        user: User,
        current_password: str,
        new_password: str
    ) -> bool:
        """Change a user's password.

        Args:
            session: Database session
            user: User object
            current_password: Current password for verification
            new_password: New password

        Returns:
            True if password was changed successfully
        """
        # Verify current password
        if not self.verify_password(current_password, user.password_hash):
            return False

        # Validate new password strength
        is_valid, errors = self.validate_password_strength(new_password)
        if not is_valid:
            raise ValueError(f"Password validation failed: {', '.join(errors)}")

        # Hash new password
        new_hash = self.hash_password(new_password)

        # Update password
        self.user_repo.update_password(session, user.id, new_hash)

        # Log password change
        self.audit_repo.log_auth_event(
            session=session,
            event_type="password_changed",
            event_category="security",
            success=True,
            user_id=user.id,
            username=user.username
        )

        logger.info(f"Password changed for user {user.username}")
        return True


# Global auth manager instance
_auth_manager: Optional[AuthManager] = None


def get_auth_manager() -> AuthManager:
    """Get the global authentication manager instance."""
    global _auth_manager
    if _auth_manager is None:
        config = {{service_class}}ServiceConfig()
        _auth_manager = AuthManager(config)
    return _auth_manager
