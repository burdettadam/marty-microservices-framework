"""
JWT Token Manager for Authentication Service
"""

import jwt
import uuid
import hashlib
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, List
import logging

from src.{{service_package}}.app.core.config import {{service_class}}ServiceConfig
from src.{{service_package}}.app.core.models import User, TokenBlacklist
from src.{{service_package}}.app.repositories import get_token_repository

logger = logging.getLogger(__name__)


class TokenManager:
    """Manages JWT token creation, validation, and blacklisting."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the token manager."""
        self.config = config
        self.token_repo = get_token_repository()

    async def initialize(self) -> None:
        """Initialize the token manager."""
        logger.info("Token manager initialized")

    def create_access_token(
        self,
        user: User,
        permissions: Optional[List[str]] = None,
        scopes: Optional[List[str]] = None,
        additional_claims: Optional[Dict[str, Any]] = None
    ) -> str:
        """Create a JWT access token for a user.

        Args:
            user: User object
            permissions: List of user permissions
            scopes: List of token scopes
            additional_claims: Additional JWT claims

        Returns:
            JWT access token string
        """
        now = datetime.now(timezone.utc)
        exp = now + self.config.jwt_access_token_expire_delta
        jti = str(uuid.uuid4())

        payload = {
            # Standard JWT claims
            "sub": str(user.id),  # Subject (user ID)
            "iat": int(now.timestamp()),  # Issued at
            "exp": int(exp.timestamp()),  # Expiration
            "jti": jti,  # JWT ID
            "iss": self.config.jwt_issuer,  # Issuer
            "aud": self.config.jwt_audience,  # Audience
            "type": "access",

            # User information
            "username": user.username,
            "email": user.email,
            "display_name": user.display_name,
            "email_verified": user.email_verified,
            "status": user.status,

            # Permissions and scopes
            "permissions": permissions or [],
            "scopes": scopes or ["read", "write"],

            # MFA status
            "mfa_enabled": user.mfa_enabled,
            "mfa_verified": False,  # Will be updated after MFA verification
        }

        # Add additional claims
        if additional_claims:
            payload.update(additional_claims)

        try:
            token = jwt.encode(
                payload,
                self.config.jwt_secret_key,
                algorithm=self.config.jwt_algorithm
            )

            logger.debug(f"Created access token for user {user.username} with JTI {jti}")
            return token

        except Exception as e:
            logger.error(f"Error creating access token: {e}")
            raise

    def create_refresh_token(
        self,
        user: User,
        session_id: Optional[str] = None
    ) -> str:
        """Create a JWT refresh token for a user.

        Args:
            user: User object
            session_id: Associated session ID

        Returns:
            JWT refresh token string
        """
        now = datetime.now(timezone.utc)
        exp = now + self.config.jwt_refresh_token_expire_delta
        jti = str(uuid.uuid4())

        payload = {
            # Standard JWT claims
            "sub": str(user.id),
            "iat": int(now.timestamp()),
            "exp": int(exp.timestamp()),
            "jti": jti,
            "iss": self.config.jwt_issuer,
            "aud": self.config.jwt_audience,
            "type": "refresh",

            # Session information
            "session_id": session_id,
            "username": user.username,
        }

        try:
            token = jwt.encode(
                payload,
                self.config.jwt_secret_key,
                algorithm=self.config.jwt_algorithm
            )

            logger.debug(f"Created refresh token for user {user.username} with JTI {jti}")
            return token

        except Exception as e:
            logger.error(f"Error creating refresh token: {e}")
            raise

    def create_service_token(
        self,
        service_name: str,
        service_id: str,
        permissions: Optional[List[str]] = None
    ) -> str:
        """Create a JWT token for service-to-service authentication.

        Args:
            service_name: Name of the service
            service_id: Unique service identifier
            permissions: List of service permissions

        Returns:
            JWT service token string
        """
        now = datetime.now(timezone.utc)
        exp = now + timedelta(minutes=self.config.service_auth_token_expire_minutes)
        jti = str(uuid.uuid4())

        payload = {
            # Standard JWT claims
            "sub": service_id,
            "iat": int(now.timestamp()),
            "exp": int(exp.timestamp()),
            "jti": jti,
            "iss": self.config.jwt_issuer,
            "aud": self.config.jwt_audience,
            "type": "service",

            # Service information
            "service_name": service_name,
            "service_id": service_id,
            "permissions": permissions or [],
        }

        try:
            token = jwt.encode(
                payload,
                self.config.service_auth_secret,
                algorithm=self.config.jwt_algorithm
            )

            logger.debug(f"Created service token for {service_name} with JTI {jti}")
            return token

        except Exception as e:
            logger.error(f"Error creating service token: {e}")
            raise

    def verify_token(
        self,
        token: str,
        token_type: Optional[str] = None,
        verify_blacklist: bool = True
    ) -> Dict[str, Any]:
        """Verify and decode a JWT token.

        Args:
            token: JWT token string
            token_type: Expected token type (access, refresh, service)
            verify_blacklist: Whether to check token blacklist

        Returns:
            Decoded token payload

        Raises:
            jwt.InvalidTokenError: If token is invalid
            ValueError: If token is blacklisted or wrong type
        """
        try:
            # Determine which secret to use based on token type hint
            secret_key = self.config.jwt_secret_key
            if token_type == "service":
                secret_key = self.config.service_auth_secret

            # Decode the token
            payload = jwt.decode(
                token,
                secret_key,
                algorithms=[self.config.jwt_algorithm],
                issuer=self.config.jwt_issuer,
                audience=self.config.jwt_audience,
                leeway=timedelta(seconds=self.config.token_validation_leeway_seconds)
            )

            # Verify token type if specified
            if token_type and payload.get("type") != token_type:
                raise ValueError(f"Expected token type '{token_type}', got '{payload.get('type')}'")

            # Check blacklist if enabled
            if verify_blacklist and self.config.token_blacklist_enabled:
                jti = payload.get("jti")
                if jti and self.is_token_blacklisted(jti):
                    raise ValueError("Token is blacklisted")

            logger.debug(f"Successfully verified token with JTI {payload.get('jti')}")
            return payload

        except jwt.ExpiredSignatureError:
            logger.warning("Token has expired")
            raise
        except jwt.InvalidTokenError as e:
            logger.warning(f"Invalid token: {e}")
            raise
        except Exception as e:
            logger.error(f"Error verifying token: {e}")
            raise

    def refresh_access_token(
        self,
        refresh_token: str,
        user: User,
        permissions: Optional[List[str]] = None
    ) -> str:
        """Create a new access token using a refresh token.

        Args:
            refresh_token: Valid refresh token
            user: User object
            permissions: User permissions

        Returns:
            New JWT access token

        Raises:
            ValueError: If refresh token is invalid
        """
        try:
            # Verify the refresh token
            payload = self.verify_token(refresh_token, token_type="refresh")

            # Verify the user matches
            if payload.get("sub") != str(user.id):
                raise ValueError("Refresh token user mismatch")

            # Create new access token
            return self.create_access_token(user, permissions)

        except Exception as e:
            logger.error(f"Error refreshing access token: {e}")
            raise

    def blacklist_token(
        self,
        session,
        token: str,
        reason: str = "revoked",
        revoked_by: Optional[str] = None,
        ip_address: Optional[str] = None
    ) -> bool:
        """Add a token to the blacklist.

        Args:
            session: Database session
            token: JWT token to blacklist
            reason: Reason for blacklisting
            revoked_by: User ID who revoked the token
            ip_address: IP address of the revocation request

        Returns:
            True if successfully blacklisted
        """
        try:
            # Decode token to get information (don't verify to allow expired tokens)
            payload = jwt.decode(
                token,
                options={"verify_signature": False, "verify_exp": False}
            )

            jti = payload.get("jti")
            if not jti:
                logger.warning("Token missing JTI, cannot blacklist")
                return False

            # Check if already blacklisted
            if self.token_repo.is_blacklisted(session, jti):
                logger.debug(f"Token {jti} already blacklisted")
                return True

            # Create blacklist entry
            token_hash = hashlib.sha256(token.encode()).hexdigest()
            exp_timestamp = payload.get("exp")
            expires_at = datetime.fromtimestamp(exp_timestamp, timezone.utc) if exp_timestamp else None

            self.token_repo.blacklist_token(
                session=session,
                jti=jti,
                token_hash=token_hash,
                user_id=payload.get("sub"),
                token_type=payload.get("type", "unknown"),
                expires_at=expires_at,
                revoke_reason=reason,
                revoked_by=revoked_by,
                ip_address=ip_address
            )

            logger.info(f"Blacklisted token {jti} for reason: {reason}")
            return True

        except Exception as e:
            logger.error(f"Error blacklisting token: {e}")
            return False

    def is_token_blacklisted(self, jti: str) -> bool:
        """Check if a token is blacklisted.

        Args:
            jti: JWT ID to check

        Returns:
            True if token is blacklisted
        """
        try:
            # Use a temporary session for the check
            from src.{{service_package}}.app.core.database import get_database_manager
            db_manager = get_database_manager()

            with db_manager.get_session() as session:
                return self.token_repo.is_blacklisted(session, jti)

        except Exception as e:
            logger.error(f"Error checking token blacklist: {e}")
            # Fail secure - assume blacklisted if we can't check
            return True

    def cleanup_expired_tokens(self, session) -> int:
        """Clean up expired tokens from the blacklist.

        Args:
            session: Database session

        Returns:
            Number of tokens cleaned up
        """
        try:
            count = self.token_repo.cleanup_expired_tokens(session)
            logger.info(f"Cleaned up {count} expired tokens from blacklist")
            return count

        except Exception as e:
            logger.error(f"Error cleaning up expired tokens: {e}")
            return 0

    def revoke_user_tokens(
        self,
        session,
        user_id: str,
        reason: str = "user_revoked",
        revoked_by: Optional[str] = None
    ) -> int:
        """Revoke all tokens for a specific user.

        Args:
            session: Database session
            user_id: User ID whose tokens to revoke
            reason: Reason for revocation
            revoked_by: User ID who initiated the revocation

        Returns:
            Number of tokens revoked
        """
        try:
            count = self.token_repo.revoke_user_tokens(
                session=session,
                user_id=user_id,
                reason=reason,
                revoked_by=revoked_by
            )

            logger.info(f"Revoked {count} tokens for user {user_id}")
            return count

        except Exception as e:
            logger.error(f"Error revoking user tokens: {e}")
            return 0

    def get_token_info(self, token: str) -> Dict[str, Any]:
        """Get information about a token without full verification.

        Args:
            token: JWT token string

        Returns:
            Token information dictionary
        """
        try:
            # Decode without verification to get claims
            payload = jwt.decode(
                token,
                options={"verify_signature": False, "verify_exp": False}
            )

            exp_timestamp = payload.get("exp")
            iat_timestamp = payload.get("iat")

            return {
                "jti": payload.get("jti"),
                "type": payload.get("type"),
                "subject": payload.get("sub"),
                "username": payload.get("username"),
                "service_name": payload.get("service_name"),
                "issued_at": datetime.fromtimestamp(iat_timestamp, timezone.utc) if iat_timestamp else None,
                "expires_at": datetime.fromtimestamp(exp_timestamp, timezone.utc) if exp_timestamp else None,
                "is_expired": exp_timestamp and datetime.now(timezone.utc).timestamp() > exp_timestamp,
                "issuer": payload.get("iss"),
                "audience": payload.get("aud"),
                "permissions": payload.get("permissions", []),
                "scopes": payload.get("scopes", [])
            }

        except Exception as e:
            logger.error(f"Error getting token info: {e}")
            return {"error": str(e)}


# Global token manager instance
_token_manager: Optional[TokenManager] = None


def get_token_manager() -> TokenManager:
    """Get the global token manager instance."""
    global _token_manager
    if _token_manager is None:
        config = {{service_class}}ServiceConfig()
        _token_manager = TokenManager(config)
    return _token_manager
