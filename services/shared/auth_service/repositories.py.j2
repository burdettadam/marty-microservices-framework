"""
Repository patterns for Authentication Service
"""

import uuid
from datetime import datetime, timezone, timedelta
from typing import Optional, List, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, desc, func

from src.{{service_package}}.app.core.models import (
    User, Role, Permission, UserRole, RolePermission, UserSession,
    ExternalAccount, AuthAuditLog, ServiceCredential, TokenBlacklist,
    UserStatus, SessionStatus
)


class BaseRepository:
    """Base repository with common operations."""

    def __init__(self, model_class):
        """Initialize repository with model class."""
        self.model_class = model_class

    def get_by_id(self, session: Session, id: str) -> Optional[object]:
        """Get record by ID."""
        return session.query(self.model_class).filter(self.model_class.id == id).first()

    def create(self, session: Session, **kwargs) -> object:
        """Create a new record."""
        instance = self.model_class(**kwargs)
        session.add(instance)
        session.flush()  # Get the ID without committing
        return instance

    def update(self, session: Session, id: str, **kwargs) -> Optional[object]:
        """Update a record by ID."""
        instance = self.get_by_id(session, id)
        if instance:
            for key, value in kwargs.items():
                setattr(instance, key, value)
            instance.version += 1
            session.flush()
        return instance

    def delete(self, session: Session, id: str) -> bool:
        """Delete a record by ID."""
        instance = self.get_by_id(session, id)
        if instance:
            session.delete(instance)
            return True
        return False


class UserRepository(BaseRepository):
    """Repository for User operations."""

    def __init__(self):
        super().__init__(User)

    def get_by_username(self, session: Session, username: str) -> Optional[User]:
        """Get user by username."""
        return session.query(User).filter(User.username == username.lower()).first()

    def get_by_email(self, session: Session, email: str) -> Optional[User]:
        """Get user by email."""
        return session.query(User).filter(User.email == email.lower()).first()

    def get_by_username_or_email(self, session: Session, identifier: str) -> Optional[User]:
        """Get user by username or email."""
        identifier = identifier.lower()
        return session.query(User).filter(
            or_(User.username == identifier, User.email == identifier)
        ).first()

    def get_by_external_id(self, session: Session, external_id: str) -> Optional[User]:
        """Get user by external ID."""
        return session.query(User).filter(User.external_id == external_id).first()

    def create_user(
        self,
        session: Session,
        username: str,
        email: str,
        password_hash: Optional[str] = None,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        display_name: Optional[str] = None,
        status: str = UserStatus.PENDING_VERIFICATION.value,
        **kwargs
    ) -> User:
        """Create a new user."""
        user = User(
            username=username.lower(),
            email=email.lower(),
            password_hash=password_hash,
            first_name=first_name,
            last_name=last_name,
            display_name=display_name or f"{first_name} {last_name}" if first_name and last_name else username,
            status=status,
            **kwargs
        )
        session.add(user)
        session.flush()
        return user

    def update_password(self, session: Session, user_id: str, password_hash: str) -> bool:
        """Update user password."""
        user = self.get_by_id(session, user_id)
        if user:
            user.password_hash = password_hash
            user.password_changed_at = datetime.now(timezone.utc)
            user.version += 1
            session.flush()
            return True
        return False

    def update_last_login(self, session: Session, user_id: str, ip_address: Optional[str] = None) -> bool:
        """Update user's last login timestamp."""
        user = self.get_by_id(session, user_id)
        if user:
            user.last_login = datetime.now(timezone.utc)
            if ip_address:
                user.last_login_ip = ip_address
            user.version += 1
            session.flush()
            return True
        return False

    def increment_failed_attempts(self, session: Session, user_id: str) -> bool:
        """Increment failed login attempts."""
        user = self.get_by_id(session, user_id)
        if user:
            user.failed_login_attempts += 1
            user.version += 1
            session.flush()
            return True
        return False

    def reset_failed_attempts(self, session: Session, user_id: str) -> bool:
        """Reset failed login attempts."""
        user = self.get_by_id(session, user_id)
        if user:
            user.failed_login_attempts = 0
            user.version += 1
            session.flush()
            return True
        return False

    def lock_account(self, session: Session, user_id: str, until: datetime) -> bool:
        """Lock user account until specified time."""
        user = self.get_by_id(session, user_id)
        if user:
            user.locked_until = until
            user.status = UserStatus.LOCKED.value
            user.version += 1
            session.flush()
            return True
        return False

    def unlock_account(self, session: Session, user_id: str) -> bool:
        """Unlock user account."""
        user = self.get_by_id(session, user_id)
        if user:
            user.locked_until = None
            user.status = UserStatus.ACTIVE.value
            user.version += 1
            session.flush()
            return True
        return False

    def verify_email(self, session: Session, user_id: str) -> bool:
        """Mark user email as verified."""
        user = self.get_by_id(session, user_id)
        if user:
            user.email_verified = True
            user.email_verification_token = None
            user.email_verification_expires = None
            if user.status == UserStatus.PENDING_VERIFICATION.value:
                user.status = UserStatus.ACTIVE.value
            user.version += 1
            session.flush()
            return True
        return False

    def setup_mfa(self, session: Session, user_id: str, secret: str, backup_codes: List[str]) -> bool:
        """Set up MFA for user (but don't enable yet)."""
        user = self.get_by_id(session, user_id)
        if user:
            user.mfa_secret = secret
            user.mfa_backup_codes = backup_codes
            user.version += 1
            session.flush()
            return True
        return False

    def enable_mfa(self, session: Session, user_id: str) -> bool:
        """Enable MFA for user."""
        user = self.get_by_id(session, user_id)
        if user:
            user.mfa_enabled = True
            user.version += 1
            session.flush()
            return True
        return False

    def disable_mfa(self, session: Session, user_id: str) -> bool:
        """Disable MFA for user."""
        user = self.get_by_id(session, user_id)
        if user:
            user.mfa_enabled = False
            user.mfa_secret = None
            user.mfa_backup_codes = None
            user.version += 1
            session.flush()
            return True
        return False

    def update_mfa_backup_codes(self, session: Session, user_id: str, backup_codes: List[str]) -> bool:
        """Update MFA backup codes."""
        user = self.get_by_id(session, user_id)
        if user:
            user.mfa_backup_codes = backup_codes
            user.version += 1
            session.flush()
            return True
        return False

    def search_users(
        self,
        session: Session,
        query: str,
        status: Optional[str] = None,
        limit: int = 50,
        offset: int = 0
    ) -> List[User]:
        """Search users by query."""
        q = session.query(User)

        if query:
            q = q.filter(
                or_(
                    User.username.ilike(f"%{query}%"),
                    User.email.ilike(f"%{query}%"),
                    User.first_name.ilike(f"%{query}%"),
                    User.last_name.ilike(f"%{query}%"),
                    User.display_name.ilike(f"%{query}%")
                )
            )

        if status:
            q = q.filter(User.status == status)

        return q.order_by(User.created_at.desc()).offset(offset).limit(limit).all()


class RoleRepository(BaseRepository):
    """Repository for Role operations."""

    def __init__(self):
        super().__init__(Role)

    def get_by_name(self, session: Session, name: str) -> Optional[Role]:
        """Get role by name."""
        return session.query(Role).filter(Role.name == name).first()

    def get_active_roles(self, session: Session) -> List[Role]:
        """Get all active roles."""
        return session.query(Role).filter(Role.is_active == True).all()

    def get_user_roles(self, session: Session, user_id: str) -> List[Role]:
        """Get all roles for a user."""
        return session.query(Role).join(UserRole).filter(
            and_(
                UserRole.user_id == user_id,
                UserRole.is_active == True,
                Role.is_active == True
            )
        ).all()


class PermissionRepository(BaseRepository):
    """Repository for Permission operations."""

    def __init__(self):
        super().__init__(Permission)

    def get_by_name(self, session: Session, name: str) -> Optional[Permission]:
        """Get permission by name."""
        return session.query(Permission).filter(Permission.name == name).first()

    def get_user_permissions(self, session: Session, user_id: str) -> List[Permission]:
        """Get all permissions for a user through their roles."""
        return session.query(Permission).join(RolePermission).join(Role).join(UserRole).filter(
            and_(
                UserRole.user_id == user_id,
                UserRole.is_active == True,
                Role.is_active == True,
                RolePermission.is_active == True,
                Permission.is_active == True
            )
        ).distinct().all()

    def get_role_permissions(self, session: Session, role_id: str) -> List[Permission]:
        """Get all permissions for a role."""
        return session.query(Permission).join(RolePermission).filter(
            and_(
                RolePermission.role_id == role_id,
                RolePermission.is_active == True,
                Permission.is_active == True
            )
        ).all()


class UserRoleRepository(BaseRepository):
    """Repository for UserRole operations."""

    def __init__(self):
        super().__init__(UserRole)

    def assign_role(
        self,
        session: Session,
        user_id: str,
        role_id: str,
        assigned_by: Optional[str] = None,
        expires_at: Optional[datetime] = None,
        context: Optional[Dict[str, Any]] = None
    ) -> UserRole:
        """Assign a role to a user."""
        user_role = UserRole(
            user_id=user_id,
            role_id=role_id,
            assigned_by=assigned_by,
            expires_at=expires_at,
            context=context
        )
        session.add(user_role)
        session.flush()
        return user_role

    def revoke_role(self, session: Session, user_id: str, role_id: str) -> bool:
        """Revoke a role from a user."""
        user_role = session.query(UserRole).filter(
            and_(
                UserRole.user_id == user_id,
                UserRole.role_id == role_id,
                UserRole.is_active == True
            )
        ).first()

        if user_role:
            user_role.is_active = False
            session.flush()
            return True
        return False

    def get_user_role_assignments(self, session: Session, user_id: str) -> List[UserRole]:
        """Get all role assignments for a user."""
        return session.query(UserRole).filter(
            and_(UserRole.user_id == user_id, UserRole.is_active == True)
        ).all()


class UserSessionRepository(BaseRepository):
    """Repository for UserSession operations."""

    def __init__(self):
        super().__init__(UserSession)

    def create(
        self,
        session: Session,
        user_id: str,
        session_token: str,
        refresh_token: Optional[str] = None,
        expires_at: Optional[datetime] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        device_info: Optional[Dict[str, Any]] = None
    ) -> UserSession:
        """Create a new user session."""
        user_session = UserSession(
            user_id=user_id,
            session_token=session_token,
            refresh_token=refresh_token,
            expires_at=expires_at or datetime.now(timezone.utc) + timedelta(hours=24),
            ip_address=ip_address,
            user_agent=user_agent,
            device_info=device_info
        )
        session.add(user_session)
        session.flush()
        return user_session

    def get_by_token(self, session: Session, session_token: str) -> Optional[UserSession]:
        """Get session by session token."""
        return session.query(UserSession).filter(
            UserSession.session_token == session_token
        ).first()

    def update_activity(self, session: Session, session_id: str) -> bool:
        """Update session last activity."""
        user_session = self.get_by_id(session, session_id)
        if user_session:
            user_session.last_activity = datetime.now(timezone.utc)
            session.flush()
            return True
        return False

    def revoke(self, session: Session, session_id: str, reason: str = "revoked") -> bool:
        """Revoke a session."""
        user_session = self.get_by_id(session, session_id)
        if user_session:
            user_session.status = SessionStatus.REVOKED.value
            user_session.revoked_at = datetime.now(timezone.utc)
            user_session.revoke_reason = reason
            session.flush()
            return True
        return False

    def revoke_user_sessions(
        self,
        session: Session,
        user_id: str,
        except_session_id: Optional[str] = None,
        reason: str = "security_revoke"
    ) -> int:
        """Revoke all sessions for a user."""
        query = session.query(UserSession).filter(
            and_(
                UserSession.user_id == user_id,
                UserSession.status == SessionStatus.ACTIVE.value
            )
        )

        if except_session_id:
            query = query.filter(UserSession.id != except_session_id)

        sessions = query.all()
        count = len(sessions)

        for user_session in sessions:
            user_session.status = SessionStatus.REVOKED.value
            user_session.revoked_at = datetime.now(timezone.utc)
            user_session.revoke_reason = reason

        session.flush()
        return count

    def cleanup_expired_sessions(self, session: Session) -> int:
        """Clean up expired sessions."""
        now = datetime.now(timezone.utc)
        expired_sessions = session.query(UserSession).filter(
            and_(
                UserSession.expires_at < now,
                UserSession.status == SessionStatus.ACTIVE.value
            )
        ).all()

        count = len(expired_sessions)
        for user_session in expired_sessions:
            user_session.status = SessionStatus.EXPIRED.value

        session.flush()
        return count


class AuthAuditRepository(BaseRepository):
    """Repository for AuthAuditLog operations."""

    def __init__(self):
        super().__init__(AuthAuditLog)

    def log_auth_event(
        self,
        session: Session,
        event_type: str,
        event_category: str,
        success: bool,
        user_id: Optional[str] = None,
        session_id: Optional[str] = None,
        username: Optional[str] = None,
        email: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
        error_message: Optional[str] = None
    ) -> AuthAuditLog:
        """Log an authentication event."""
        audit_log = AuthAuditLog(
            user_id=user_id,
            session_id=session_id,
            event_type=event_type,
            event_category=event_category,
            success=success,
            username=username,
            email=email,
            ip_address=ip_address,
            user_agent=user_agent,
            details=details,
            error_message=error_message
        )
        session.add(audit_log)
        session.flush()
        return audit_log

    def get_user_audit_log(
        self,
        session: Session,
        user_id: str,
        limit: int = 100,
        offset: int = 0
    ) -> List[AuthAuditLog]:
        """Get audit log for a user."""
        return session.query(AuthAuditLog).filter(
            AuthAuditLog.user_id == user_id
        ).order_by(desc(AuthAuditLog.timestamp)).offset(offset).limit(limit).all()

    def get_failed_login_attempts(
        self,
        session: Session,
        ip_address: Optional[str] = None,
        username: Optional[str] = None,
        since: Optional[datetime] = None
    ) -> List[AuthAuditLog]:
        """Get failed login attempts."""
        query = session.query(AuthAuditLog).filter(
            and_(
                AuthAuditLog.event_type == "login_failed",
                AuthAuditLog.success == False
            )
        )

        if ip_address:
            query = query.filter(AuthAuditLog.ip_address == ip_address)

        if username:
            query = query.filter(AuthAuditLog.username == username)

        if since:
            query = query.filter(AuthAuditLog.timestamp >= since)

        return query.order_by(desc(AuthAuditLog.timestamp)).all()


class TokenRepository(BaseRepository):
    """Repository for TokenBlacklist operations."""

    def __init__(self):
        super().__init__(TokenBlacklist)

    def blacklist_token(
        self,
        session: Session,
        jti: str,
        token_hash: str,
        user_id: Optional[str] = None,
        token_type: str = "access",
        expires_at: Optional[datetime] = None,
        revoke_reason: Optional[str] = None,
        revoked_by: Optional[str] = None,
        ip_address: Optional[str] = None
    ) -> TokenBlacklist:
        """Add a token to the blacklist."""
        blacklist_entry = TokenBlacklist(
            jti=jti,
            token_hash=token_hash,
            user_id=user_id,
            token_type=token_type,
            expires_at=expires_at or datetime.now(timezone.utc) + timedelta(days=1),
            revoke_reason=revoke_reason,
            revoked_by=revoked_by,
            ip_address=ip_address
        )
        session.add(blacklist_entry)
        session.flush()
        return blacklist_entry

    def is_blacklisted(self, session: Session, jti: str) -> bool:
        """Check if a token is blacklisted."""
        return session.query(TokenBlacklist).filter(
            TokenBlacklist.jti == jti
        ).first() is not None

    def cleanup_expired_tokens(self, session: Session) -> int:
        """Clean up expired tokens from blacklist."""
        now = datetime.now(timezone.utc)
        expired_tokens = session.query(TokenBlacklist).filter(
            TokenBlacklist.expires_at < now
        ).all()

        count = len(expired_tokens)
        for token in expired_tokens:
            session.delete(token)

        session.flush()
        return count

    def revoke_user_tokens(
        self,
        session: Session,
        user_id: str,
        reason: str = "user_revoked",
        revoked_by: Optional[str] = None
    ) -> int:
        """This would be called when we have active tokens to revoke."""
        # In a real implementation, this would find active tokens for the user
        # and add them to the blacklist. For now, we'll return 0.
        return 0


class ExternalAccountRepository(BaseRepository):
    """Repository for ExternalAccount operations."""

    def __init__(self):
        super().__init__(ExternalAccount)

    def get_by_provider_and_external_id(
        self,
        session: Session,
        provider: str,
        external_id: str
    ) -> Optional[ExternalAccount]:
        """Get external account by provider and external ID."""
        return session.query(ExternalAccount).filter(
            and_(
                ExternalAccount.provider == provider,
                ExternalAccount.external_id == external_id,
                ExternalAccount.is_active == True
            )
        ).first()

    def get_user_external_accounts(self, session: Session, user_id: str) -> List[ExternalAccount]:
        """Get all external accounts for a user."""
        return session.query(ExternalAccount).filter(
            and_(
                ExternalAccount.user_id == user_id,
                ExternalAccount.is_active == True
            )
        ).all()

    def link_external_account(
        self,
        session: Session,
        user_id: str,
        provider: str,
        external_id: str,
        external_username: Optional[str] = None,
        external_email: Optional[str] = None,
        access_token: Optional[str] = None,
        refresh_token: Optional[str] = None,
        token_expires_at: Optional[datetime] = None,
        profile_data: Optional[Dict[str, Any]] = None
    ) -> ExternalAccount:
        """Link an external account to a user."""
        external_account = ExternalAccount(
            user_id=user_id,
            provider=provider,
            external_id=external_id,
            external_username=external_username,
            external_email=external_email,
            access_token=access_token,
            refresh_token=refresh_token,
            token_expires_at=token_expires_at,
            profile_data=profile_data
        )
        session.add(external_account)
        session.flush()
        return external_account


# Repository factory functions
def get_user_repository() -> UserRepository:
    """Get user repository instance."""
    return UserRepository()


def get_role_repository() -> RoleRepository:
    """Get role repository instance."""
    return RoleRepository()


def get_permission_repository() -> PermissionRepository:
    """Get permission repository instance."""
    return PermissionRepository()


def get_user_role_repository() -> UserRoleRepository:
    """Get user role repository instance."""
    return UserRoleRepository()


def get_session_repository() -> UserSessionRepository:
    """Get session repository instance."""
    return UserSessionRepository()


def get_audit_repository() -> AuthAuditRepository:
    """Get audit repository instance."""
    return AuthAuditRepository()


def get_token_repository() -> TokenRepository:
    """Get token repository instance."""
    return TokenRepository()


def get_external_account_repository() -> ExternalAccountRepository:
    """Get external account repository instance."""
    return ExternalAccountRepository()
