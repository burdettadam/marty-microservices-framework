"""
Message Producers for Message Queue Service
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List
from datetime import datetime, timezone
import uuid

from src.{{service_package}}.app.core.config import {{service_class}}ServiceConfig
from src.{{service_package}}.app.core.models import Message, MessageMetadata, DeliveryGuarantee
from src.{{service_package}}.app.message_queue.kafka_manager import get_kafka_manager
from src.{{service_package}}.app.message_queue.rabbitmq_manager import get_rabbitmq_manager
from src.{{service_package}}.app.message_queue.redis_manager import get_redis_manager

logger = logging.getLogger(__name__)


class MessageProducer:
    """Base message producer interface."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the message producer."""
        self.config = config

    async def send_message(
        self,
        destination: str,
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None
    ) -> bool:
        """Send a message to the specified destination.

        Args:
            destination: Target topic/queue/channel/stream
            message_type: Type of message
            data: Message payload
            metadata: Optional message metadata
            delivery_guarantee: Optional delivery guarantee override

        Returns:
            True if message was sent successfully
        """
        raise NotImplementedError

    async def send_batch(
        self,
        destination: str,
        messages: List[Dict[str, Any]],
        delivery_guarantee: Optional[DeliveryGuarantee] = None
    ) -> List[bool]:
        """Send a batch of messages.

        Args:
            destination: Target destination
            messages: List of message dictionaries with 'type', 'data', and optional 'metadata'
            delivery_guarantee: Optional delivery guarantee override

        Returns:
            List of success indicators for each message
        """
        results = []
        for msg in messages:
            result = await self.send_message(
                destination=destination,
                message_type=msg['type'],
                data=msg['data'],
                metadata=msg.get('metadata'),
                delivery_guarantee=delivery_guarantee
            )
            results.append(result)
        return results

    def _create_message(
        self,
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None
    ) -> Message:
        """Create a Message object with default metadata."""
        if metadata is None:
            metadata = MessageMetadata(
                timestamp=datetime.now(timezone.utc),
                source=self.config.service_name,
                version="1.0",
                correlation_id=str(uuid.uuid4()),
                causation_id=None,
                user_id=None,
                session_id=None,
                trace_id=None,
                span_id=None,
                headers={},
                tags=[]
            )

        return Message(
            id=str(uuid.uuid4()),
            type=message_type,
            data=data,
            metadata=metadata
        )


class KafkaProducer(MessageProducer):
    """Kafka message producer."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the Kafka producer."""
        super().__init__(config)
        self.kafka_manager = get_kafka_manager()

    async def send_message(
        self,
        destination: str,  # Kafka topic
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None,
        key: Optional[str] = None,
        partition: Optional[int] = None,
        headers: Optional[Dict[str, bytes]] = None
    ) -> bool:
        """Send a message to Kafka topic."""
        try:
            message = self._create_message(message_type, data, metadata)

            success = await self.kafka_manager.produce_message(
                topic=destination,
                message=message,
                key=key,
                partition=partition,
                headers=headers
            )

            if success:
                logger.debug(f"Kafka message sent: {message.id} to topic {destination}")
            else:
                logger.error(f"Failed to send Kafka message: {message.id} to topic {destination}")

            return success

        except Exception as e:
            logger.error(f"Error sending Kafka message to topic {destination}: {e}")
            return False

    async def send_batch(
        self,
        destination: str,
        messages: List[Dict[str, Any]],
        delivery_guarantee: Optional[DeliveryGuarantee] = None
    ) -> List[bool]:
        """Send a batch of messages to Kafka topic."""
        results = []

        # Send messages concurrently for better performance
        tasks = []
        for msg in messages:
            task = self.send_message(
                destination=destination,
                message_type=msg['type'],
                data=msg['data'],
                metadata=msg.get('metadata'),
                delivery_guarantee=delivery_guarantee,
                key=msg.get('key'),
                partition=msg.get('partition'),
                headers=msg.get('headers')
            )
            tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Convert exceptions to False
        return [result if isinstance(result, bool) else False for result in results]


class RabbitMQProducer(MessageProducer):
    """RabbitMQ message producer."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the RabbitMQ producer."""
        super().__init__(config)
        self.rabbitmq_manager = get_rabbitmq_manager()

    async def send_message(
        self,
        destination: str,  # RabbitMQ exchange
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None,
        routing_key: str = "",
        mandatory: bool = False,
        immediate: bool = False
    ) -> bool:
        """Send a message to RabbitMQ exchange."""
        try:
            message = self._create_message(message_type, data, metadata)

            success = await self.rabbitmq_manager.publish_message(
                exchange_name=destination,
                message=message,
                routing_key=routing_key,
                mandatory=mandatory,
                immediate=immediate
            )

            if success:
                logger.debug(f"RabbitMQ message sent: {message.id} to exchange {destination}")
            else:
                logger.error(f"Failed to send RabbitMQ message: {message.id} to exchange {destination}")

            return success

        except Exception as e:
            logger.error(f"Error sending RabbitMQ message to exchange {destination}: {e}")
            return False

    async def send_to_queue(
        self,
        queue_name: str,
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None
    ) -> bool:
        """Send a message directly to a RabbitMQ queue."""
        # Use default exchange with queue name as routing key
        return await self.send_message(
            destination="",  # Default exchange
            message_type=message_type,
            data=data,
            metadata=metadata,
            delivery_guarantee=delivery_guarantee,
            routing_key=queue_name
        )


class RedisProducer(MessageProducer):
    """Redis message producer for streams and pub/sub."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the Redis producer."""
        super().__init__(config)
        self.redis_manager = get_redis_manager()

    async def send_to_stream(
        self,
        stream_name: str,
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None,
        message_id: Optional[str] = None,
        maxlen: Optional[int] = None,
        approximate: bool = True
    ) -> Optional[str]:
        """Send a message to Redis stream.

        Returns:
            Stream message ID if successful, None otherwise
        """
        try:
            message = self._create_message(message_type, data, metadata)

            stream_id = await self.redis_manager.add_to_stream(
                stream_name=stream_name,
                message=message,
                message_id=message_id,
                maxlen=maxlen,
                approximate=approximate
            )

            logger.debug(f"Redis stream message sent: {message.id} to stream {stream_name} with ID {stream_id}")
            return stream_id

        except Exception as e:
            logger.error(f"Error sending Redis stream message to {stream_name}: {e}")
            return None

    async def publish_to_channel(
        self,
        channel: str,
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None
    ) -> int:
        """Publish a message to Redis channel.

        Returns:
            Number of subscribers that received the message
        """
        try:
            message = self._create_message(message_type, data, metadata)

            subscribers = await self.redis_manager.publish_message(
                channel=channel,
                message=message
            )

            logger.debug(f"Redis pub/sub message published: {message.id} to channel {channel}, reached {subscribers} subscribers")
            return subscribers

        except Exception as e:
            logger.error(f"Error publishing Redis message to channel {channel}: {e}")
            return 0

    async def send_message(
        self,
        destination: str,
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None
    ) -> bool:
        """Send a message to Redis (defaults to stream)."""
        stream_id = await self.send_to_stream(
            stream_name=destination,
            message_type=message_type,
            data=data,
            metadata=metadata,
            delivery_guarantee=delivery_guarantee
        )
        return stream_id is not None


class UnifiedProducer:
    """Unified producer that can send messages to multiple brokers."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the unified producer."""
        self.config = config
        self.producers = {}

        # Initialize enabled producers
        if config.kafka_enabled:
            self.producers['kafka'] = KafkaProducer(config)

        if config.rabbitmq_enabled:
            self.producers['rabbitmq'] = RabbitMQProducer(config)

        if config.redis_enabled:
            self.producers['redis'] = RedisProducer(config)

    async def send_message(
        self,
        broker: str,
        destination: str,
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None,
        **kwargs
    ) -> bool:
        """Send a message using the specified broker.

        Args:
            broker: Broker type ('kafka', 'rabbitmq', 'redis')
            destination: Target destination (topic/exchange/queue/stream/channel)
            message_type: Type of message
            data: Message payload
            metadata: Optional message metadata
            delivery_guarantee: Optional delivery guarantee override
            **kwargs: Broker-specific parameters

        Returns:
            True if message was sent successfully
        """
        if broker not in self.producers:
            logger.error(f"Producer for broker '{broker}' not available")
            return False

        try:
            producer = self.producers[broker]

            if broker == 'kafka':
                return await producer.send_message(
                    destination=destination,
                    message_type=message_type,
                    data=data,
                    metadata=metadata,
                    delivery_guarantee=delivery_guarantee,
                    key=kwargs.get('key'),
                    partition=kwargs.get('partition'),
                    headers=kwargs.get('headers')
                )

            elif broker == 'rabbitmq':
                return await producer.send_message(
                    destination=destination,
                    message_type=message_type,
                    data=data,
                    metadata=metadata,
                    delivery_guarantee=delivery_guarantee,
                    routing_key=kwargs.get('routing_key', ''),
                    mandatory=kwargs.get('mandatory', False),
                    immediate=kwargs.get('immediate', False)
                )

            elif broker == 'redis':
                if kwargs.get('use_pubsub', False):
                    subscribers = await producer.publish_to_channel(
                        channel=destination,
                        message_type=message_type,
                        data=data,
                        metadata=metadata,
                        delivery_guarantee=delivery_guarantee
                    )
                    return subscribers > 0
                else:
                    stream_id = await producer.send_to_stream(
                        stream_name=destination,
                        message_type=message_type,
                        data=data,
                        metadata=metadata,
                        delivery_guarantee=delivery_guarantee,
                        message_id=kwargs.get('message_id'),
                        maxlen=kwargs.get('maxlen'),
                        approximate=kwargs.get('approximate', True)
                    )
                    return stream_id is not None

            return False

        except Exception as e:
            logger.error(f"Error sending message via {broker} to {destination}: {e}")
            return False

    async def broadcast_message(
        self,
        brokers: List[str],
        destinations: Dict[str, str],
        message_type: str,
        data: Dict[str, Any],
        metadata: Optional[MessageMetadata] = None,
        delivery_guarantee: Optional[DeliveryGuarantee] = None
    ) -> Dict[str, bool]:
        """Broadcast a message to multiple brokers.

        Args:
            brokers: List of broker names
            destinations: Mapping of broker to destination
            message_type: Type of message
            data: Message payload
            metadata: Optional message metadata
            delivery_guarantee: Optional delivery guarantee override

        Returns:
            Dictionary mapping broker to success status
        """
        results = {}

        # Send to all brokers concurrently
        tasks = []
        for broker in brokers:
            if broker in destinations:
                task = self.send_message(
                    broker=broker,
                    destination=destinations[broker],
                    message_type=message_type,
                    data=data,
                    metadata=metadata,
                    delivery_guarantee=delivery_guarantee
                )
                tasks.append((broker, task))

        # Wait for all sends to complete
        for broker, task in tasks:
            try:
                result = await task
                results[broker] = result
            except Exception as e:
                logger.error(f"Error broadcasting to {broker}: {e}")
                results[broker] = False

        return results

    def get_producer(self, broker: str) -> Optional[MessageProducer]:
        """Get a specific producer instance."""
        return self.producers.get(broker)


# Global unified producer instance
_unified_producer: Optional[UnifiedProducer] = None


def get_unified_producer() -> UnifiedProducer:
    """Get the global unified producer instance."""
    global _unified_producer
    if _unified_producer is None:
        config = {{service_class}}ServiceConfig()
        _unified_producer = UnifiedProducer(config)
    return _unified_producer


def get_kafka_producer() -> Optional[KafkaProducer]:
    """Get the Kafka producer instance."""
    return get_unified_producer().get_producer('kafka')


def get_rabbitmq_producer() -> Optional[RabbitMQProducer]:
    """Get the RabbitMQ producer instance."""
    return get_unified_producer().get_producer('rabbitmq')


def get_redis_producer() -> Optional[RedisProducer]:
    """Get the Redis producer instance."""
    return get_unified_producer().get_producer('redis')
