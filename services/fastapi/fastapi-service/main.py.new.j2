"""
{{project_description}}

A FastAPI microservice built with the Marty framework.
This file contains the simplified main.py that leverages the framework's
unified service runner instead of custom startup code.

Author: {{author_name}}
Email: {{author_email}}
"""

import os
from datetime import datetime
from typing import Dict, Any, Optional

from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import structlog

# Configure structured logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()


# Pydantic models
class HealthResponse(BaseModel):
    """Health check response model."""
    status: str = "healthy"
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    version: str = "{{framework_version}}"
    service: str = "{{project_slug}}"


class ErrorResponse(BaseModel):
    """Error response model."""
    error: str
    message: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    trace_id: Optional[str] = None


# Create FastAPI application
def create_app() -> FastAPI:
    """Create and configure the FastAPI application."""

    app = FastAPI(
        title="{{project_name}}",
        description="{{project_description}}",
        version="1.0.0",
        {% if enable_docs %}
        docs_url="/docs",
        redoc_url="/redoc",
        {% else %}
        docs_url=None,
        redoc_url=None,
        {% endif %}
        openapi_url="/openapi.json" if {{enable_docs}} else None
    )

    # Add middleware
    {% if enable_cors %}
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Configure appropriately for production
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    {% endif %}

    {% if enable_compression %}
    app.add_middleware(GZipMiddleware, minimum_size=1000)
    {% endif %}

    # Error handling
    @app.exception_handler(HTTPException)
    async def http_exception_handler(request: Request, exc: HTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content=ErrorResponse(
                error=exc.__class__.__name__,
                message=str(exc.detail),
                trace_id=request.headers.get("x-trace-id")
            ).dict()
        )

    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        logger.error("Unhandled exception", exception=str(exc), path=request.url.path)
        return JSONResponse(
            status_code=500,
            content=ErrorResponse(
                error=exc.__class__.__name__,
                message="Internal server error",
                trace_id=request.headers.get("x-trace-id")
            ).dict()
        )

    # Routes
    {% if enable_health_checks %}
    @app.get("/health", response_model=HealthResponse)
    async def health_check():
        """Health check endpoint."""
        return HealthResponse()

    @app.get("/ready", response_model=HealthResponse)
    async def readiness_check():
        """Readiness check endpoint."""
        # Add any readiness checks here (database connections, etc.)
        return HealthResponse(status="ready")
    {% endif %}

    {% if enable_monitoring %}
    @app.get("/metrics")
    async def metrics():
        """Prometheus metrics endpoint."""
        from prometheus_client import generate_latest, CONTENT_TYPE_LATEST
        from fastapi.responses import Response
        return Response(content=generate_latest(), media_type=CONTENT_TYPE_LATEST)
    {% endif %}

    @app.get("/")
    async def root():
        """Root endpoint."""
        return {
            "service": "{{project_slug}}",
            "version": "1.0.0",
            "description": "{{project_description}}",
            "docs_url": "/docs" if {{enable_docs}} else None
        }

    # Example API endpoints
    @app.get("/api/status")
    async def get_status():
        """Get service status."""
        return {
            "status": "running",
            "service": "{{project_slug}}",
            "timestamp": datetime.utcnow().isoformat()
        }

    # Add your custom endpoints here
    # Example:
    # @app.get("/api/items")
    # async def list_items():
    #     """List items."""
    #     return {"items": []}

    return app


# Create the app instance - this is what the framework will import and run
app = create_app()

# Optional: Add application lifespan events
@app.on_event("startup")
async def startup_event():
    """Application startup event."""
    logger.info("{{project_name}} service starting up")
    # Add startup logic here (database connections, etc.)


@app.on_event("shutdown")
async def shutdown_event():
    """Application shutdown event."""
    logger.info("{{project_name}} service shutting down")
    # Add cleanup logic here
