"""
{{service_description | default("Production-ready FastAPI microservice built with Marty Microservices Framework")}}

This service follows enterprise patterns and the MMF adoption flow:
clone → generate → add business logic

Features:
- Comprehensive logging with correlation IDs
- Prometheus metrics integration
- Health checks and readiness probes
- Structured configuration management
- Error handling and audit logging
- Service mesh ready

Service: {{service_name}}
Generated with MMF Service Generator
"""
import asyncio
import json
import logging
import sys
import time
import uuid
from contextlib import asynccontextmanager
from datetime import datetime
from typing import Any, Dict, Optional

import uvicorn
from fastapi import FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from prometheus_client import Counter, Gauge, Histogram, generate_latest, CONTENT_TYPE_LATEST

# Import unified components
from marty_msf.framework.config import UnifiedConfigurationManager
from marty_msf.framework.secrets import UnifiedSecrets
from marty_msf.observability.standard import create_standard_observability, set_global_observability
from marty_msf.observability.standard_correlation import StandardCorrelationMiddleware
from app.api.routes import router
from app.services.{{service_package}}_service import {{service_class}}Service

# Configure structured logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('{{service_package}}_service.log'),
        logging.FileHandler('{{service_package}}_service_audit.log')
    ]
)
logger = logging.getLogger("{{service_name}}")

# Prometheus Metrics (with duplicate registration protection)
from prometheus_client import REGISTRY, CollectorRegistry

# Initialize metrics with error handling for duplicates
REQUEST_COUNTER = None
REQUEST_DURATION = None
ACTIVE_REQUESTS = None
BUSINESS_OPERATIONS = None

try:
    REQUEST_COUNTER = Counter('{{service_package}}_requests_total', 'Total requests', ['method', 'endpoint', 'status'])
    REQUEST_DURATION = Histogram('{{service_package}}_request_duration_seconds', 'Request duration', ['method', 'endpoint'])
    ACTIVE_REQUESTS = Gauge('{{service_package}}_active_requests', 'Active requests')
    BUSINESS_OPERATIONS = Counter('{{service_package}}_business_operations_total', 'Business operations', ['operation', 'status'])
except ValueError as e:
    if "Duplicated timeseries" in str(e):
        logger.warning(f"Metrics already registered: {e}")
        # Create with different registry or skip metrics
        pass
    else:
        raise

# Global instances
config_manager = None
secrets_manager = None
observability = None
service_instance = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan management with unified infrastructure"""
    global config_manager, secrets_manager, observability, service_instance

    # Initialize unified configuration
    config_manager = UnifiedConfigurationManager()
    await config_manager.initialize()

    # Initialize unified secrets
    secrets_manager = UnifiedSecrets()
    await secrets_manager.initialize()

    service_name = config_manager.get("service.name", "{{service_name}}")

    # Startup
    logger.info(f"Starting {service_name} with unified infrastructure...")

    # Initialize unified observability
    observability = create_standard_observability(
        service_name=service_name,
        service_version=config_manager.get("service.version", "1.0.0"),
        service_type="fastapi"
    )
    await observability.initialize()
    set_global_observability(observability)

    try:
        service_instance = {{service_class}}Service(
            config_manager=config_manager,
            secrets_manager=secrets_manager
        )
        await service_instance.initialize()
        logger.info("Service initialized successfully")

        # Store in app state
        app.state.config_manager = config_manager
        app.state.secrets_manager = secrets_manager
        app.state.service = service_instance

    except Exception as e:
        logger.error(f"Failed to initialize service: {e}")
        raise

    yield

    # Shutdown
    logger.info("Shutting down {{service_name}}...")
    if service_instance:
        await service_instance.cleanup()
    if observability:
        await observability.shutdown()
    if secrets_manager:
        await secrets_manager.cleanup()
    if config_manager:
        await config_manager.cleanup()
    logger.info("Service shutdown complete")

# Create FastAPI app
app = FastAPI(
    title="{{service_class}} Service",
    description="{{service_description | default('Production-ready microservice built with Marty Microservices Framework')}}",
    version="1.0.0",
    lifespan=lifespan,
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add unified correlation middleware
app.add_middleware(StandardCorrelationMiddleware)

# Metrics middleware
@app.middleware("http")
async def metrics_middleware(request: Request, call_next):
    """Middleware to collect metrics for all requests"""
    start_time = time.time()
    if ACTIVE_REQUESTS:
        ACTIVE_REQUESTS.inc()

    try:
        response = await call_next(request)

        # Record metrics (if available)
        duration = time.time() - start_time
        if REQUEST_DURATION:
            REQUEST_DURATION.labels(method=request.method, endpoint=request.url.path).observe(duration)
        if REQUEST_COUNTER:
            REQUEST_COUNTER.labels(
                method=request.method,
                endpoint=request.url.path,
                status=response.status_code
            ).inc()

        return response
    finally:
        if ACTIVE_REQUESTS:
            ACTIVE_REQUESTS.dec()

# Exception handlers
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Handle HTTP exceptions with proper logging"""
    correlation_id = getattr(request.state, 'correlation_id', 'unknown')

    error_data = {
        "event": "http_exception",
        "correlation_id": correlation_id,
        "status_code": exc.status_code,
        "detail": exc.detail,
        "path": request.url.path,
        "method": request.method,
        "timestamp": datetime.utcnow().isoformat()
    }

    logger.warning(f"HTTP Exception: {json.dumps(error_data)}")

    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.detail,
            "correlation_id": correlation_id,
            "timestamp": datetime.utcnow().isoformat()
        }
    )

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Handle unexpected exceptions"""
    correlation_id = getattr(request.state, 'correlation_id', 'unknown')

    error_data = {
        "event": "unexpected_exception",
        "correlation_id": correlation_id,
        "error": str(exc),
        "error_type": type(exc).__name__,
        "path": request.url.path,
        "method": request.method,
        "timestamp": datetime.utcnow().isoformat()
    }

    logger.error(f"Unexpected Exception: {json.dumps(error_data)}", exc_info=True)

    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal server error",
            "correlation_id": correlation_id,
            "timestamp": datetime.utcnow().isoformat()
        }
    )

# Health and monitoring endpoints
@app.get("/health", tags=["monitoring"])
async def health_check():
    """Health check endpoint for load balancers and orchestrators"""
    return {
        "status": "healthy",
        "service": "{{service_name}}",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "1.0.0"
    }

@app.get("/ready", tags=["monitoring"])
async def readiness_check():
    """Readiness check endpoint"""
    try:
        # Add your readiness checks here (database connections, external services, etc.)
        if service_instance:
            is_ready = await service_instance.health_check()
            if is_ready:
                return {
                    "status": "ready",
                    "service": "{{service_name}}",
                    "timestamp": datetime.utcnow().isoformat()
                }

        raise HTTPException(status_code=503, detail="Service not ready")
    except Exception as e:
        logger.error(f"Readiness check failed: {e}")
        raise HTTPException(status_code=503, detail="Service not ready")

@app.get("/metrics", tags=["monitoring"])
async def get_metrics():
    """Prometheus metrics endpoint"""
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

@app.get("/info", tags=["monitoring"])
async def service_info():
    """Service information endpoint"""
    settings = get_settings()
    return {
        "service": "{{service_name}}",
        "version": "1.0.0",
        "description": "{{service_description | default('Production-ready microservice built with Marty Microservices Framework')}}",
        "environment": getattr(settings, 'environment', 'unknown'),
        "framework": "Marty Microservices Framework",
        "generated_at": "2025-10-13 12:00:00",
        "timestamp": datetime.utcnow().isoformat()
    }

# Include API routes
app.include_router(router, prefix="/api/v1")

def get_service() -> {{service_class}}Service:
    """Get the service instance"""
    if service_instance is None:
        raise HTTPException(status_code=503, detail="Service not initialized")
    return service_instance

async def main():
    """Main application entry point with unified configuration"""
    # Initialize config temporarily to get server settings
    temp_config = UnifiedConfigurationManager()
    await temp_config.initialize()

    port = temp_config.get("server.port", {{http_port}})
    host = temp_config.get("server.host", "0.0.0.0")
    debug = temp_config.get("server.debug", False)

    print(f"🚀 Starting {{service_class}} Service with unified infrastructure...")
    print(f"📊 Metrics: http://{host}:{port}/metrics")
    print(f"📋 API Docs: http://{host}:{port}/docs")
    print(f"❤️  Health: http://{host}:{port}/health")
    print(f"🔄 Ready: http://{host}:{port}/ready")

    uvicorn_config = uvicorn.Config(
        app,
        host=host,
        port=port,
        reload=debug,
        log_level=temp_config.get("logging.level", "info").lower()
    )

    await temp_config.cleanup()

    server = uvicorn.Server(uvicorn_config)
    await server.serve()

if __name__ == "__main__":
    asyncio.run(main())
