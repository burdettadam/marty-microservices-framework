"""
Middleware components for {{service_class}} Service

This module provides middleware functions following the Marty framework patterns:
- Correlation ID tracking for distributed tracing
- Request/response logging
- Error handling
- Security headers
"""
import json
import time
import uuid
from datetime import datetime
from typing import Callable

from fastapi import FastAPI, Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp
import logging

logger = logging.getLogger("{{service_name}}.middleware")

class CorrelationIdMiddleware(BaseHTTPMiddleware):
    """
    Middleware to add correlation IDs to all requests for distributed tracing.

    This middleware:
    - Extracts correlation ID from X-Correlation-ID header
    - Generates new correlation ID if not provided
    - Adds correlation ID to request state
    - Includes correlation ID in response headers
    """

    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        # Extract or generate correlation ID
        correlation_id = request.headers.get("X-Correlation-ID")
        if not correlation_id:
            correlation_id = str(uuid.uuid4())

        # Add to request state for access in route handlers
        request.state.correlation_id = correlation_id

        # Log request
        request_data = {
            "event": "request_started",
            "correlation_id": correlation_id,
            "method": request.method,
            "path": request.url.path,
            "query_params": str(request.query_params),
            "client_ip": request.client.host if request.client else "unknown",
            "user_agent": request.headers.get("user-agent", "unknown"),
            "timestamp": datetime.utcnow().isoformat()
        }
        logger.info(f"REQUEST: {json.dumps(request_data)}")

        # Process request
        start_time = time.time()
        response = await call_next(request)
        processing_time = time.time() - start_time

        # Add correlation ID to response headers
        response.headers["X-Correlation-ID"] = correlation_id

        # Log response
        response_data = {
            "event": "request_completed",
            "correlation_id": correlation_id,
            "method": request.method,
            "path": request.url.path,
            "status_code": response.status_code,
            "processing_time_ms": round(processing_time * 1000, 2),
            "timestamp": datetime.utcnow().isoformat()
        }
        logger.info(f"RESPONSE: {json.dumps(response_data)}")

        return response

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """
    Middleware to add security headers to all responses.

    Adds standard security headers:
    - X-Content-Type-Options
    - X-Frame-Options
    - X-XSS-Protection
    - Strict-Transport-Security (in production)
    """

    def __init__(self, app: ASGIApp, environment: str = "development"):
        super().__init__(app)
        self.environment = environment

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        response = await call_next(request)

        # Add security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"

        # Add HSTS header in production
        if self.environment.lower() == "production":
            response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"

        return response

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """
    Detailed request/response logging middleware.

    Logs comprehensive request and response information for audit and debugging.
    """

    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        # Get correlation ID from previous middleware
        correlation_id = getattr(request.state, 'correlation_id', str(uuid.uuid4()))

        # Log detailed request information
        request_body = None
        if request.method in ["POST", "PUT", "PATCH"]:
            try:
                # Read and restore request body for logging
                body = await request.body()
                if body:
                    request_body = body.decode('utf-8')[:1000]  # Limit body size in logs
            except Exception as e:
                logger.warning(f"Failed to read request body for logging: {e}")

        detailed_request = {
            "event": "detailed_request_log",
            "correlation_id": correlation_id,
            "method": request.method,
            "url": str(request.url),
            "headers": dict(request.headers),
            "path_params": request.path_params,
            "query_params": dict(request.query_params),
            "client": {
                "host": request.client.host if request.client else None,
                "port": request.client.port if request.client else None
            },
            "body_preview": request_body,
            "timestamp": datetime.utcnow().isoformat()
        }

        # Remove sensitive headers from logs
        sensitive_headers = {"authorization", "cookie", "x-api-key"}
        for header in sensitive_headers:
            if header in detailed_request["headers"]:
                detailed_request["headers"][header] = "[REDACTED]"

        logger.debug(f"DETAILED_REQUEST: {json.dumps(detailed_request)}")

        # Process request
        start_time = time.time()
        response = await call_next(request)
        processing_time = time.time() - start_time

        # Log detailed response information
        detailed_response = {
            "event": "detailed_response_log",
            "correlation_id": correlation_id,
            "status_code": response.status_code,
            "headers": dict(response.headers),
            "processing_time_ms": round(processing_time * 1000, 2),
            "content_type": response.headers.get("content-type"),
            "content_length": response.headers.get("content-length"),
            "timestamp": datetime.utcnow().isoformat()
        }

        logger.debug(f"DETAILED_RESPONSE: {json.dumps(detailed_response)}")

        return response

def add_correlation_id_middleware(app: FastAPI) -> None:
    """
    Add correlation ID middleware to the FastAPI app.

    Args:
        app: FastAPI application instance
    """
    app.add_middleware(CorrelationIdMiddleware)

def add_security_headers_middleware(app: FastAPI, environment: str = "development") -> None:
    """
    Add security headers middleware to the FastAPI app.

    Args:
        app: FastAPI application instance
        environment: Application environment
    """
    app.add_middleware(SecurityHeadersMiddleware, environment=environment)

def add_request_logging_middleware(app: FastAPI) -> None:
    """
    Add request logging middleware to the FastAPI app.

    Args:
        app: FastAPI application instance
    """
    app.add_middleware(RequestLoggingMiddleware)

def setup_middleware(app: FastAPI, environment: str = "development") -> None:
    """
    Setup all middleware components for the application.

    Args:
        app: FastAPI application instance
        environment: Application environment
    """
    # Add middleware in reverse order (last added is executed first)
    add_request_logging_middleware(app)
    add_security_headers_middleware(app, environment)
    add_correlation_id_middleware(app)
