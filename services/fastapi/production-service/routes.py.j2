"""
API Routes for {{service_class}} Service

This module defines the API endpoints for the service following REST principles
and the Marty framework patterns for observability and error handling.

Add your specific API endpoints to this router while maintaining the established patterns.
"""
import json
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Request, status
from pydantic import BaseModel, Field

from app.models.{{service_package}}_models import (
    {{service_class}}Request,
    {{service_class}}Response,
    ErrorResponse
)
from app.services.{{service_package}}_service import {{service_class}}Service
from app.core.config import get_settings
import logging

logger = logging.getLogger("{{service_name}}.api")

# Create API router
router = APIRouter(
    prefix="",
    tags=["{{service_name}}"],
    responses={
        500: {"model": ErrorResponse, "description": "Internal server error"},
        400: {"model": ErrorResponse, "description": "Bad request"},
        404: {"model": ErrorResponse, "description": "Not found"}
    }
)

# Dependency to get service instance
def get_service() -> {{service_class}}Service:
    """
    Dependency to get the service instance.

    This will be replaced with proper dependency injection
    when the service is running within the application context.
    """
    # This is a placeholder - in the actual application,
    # the service instance will be injected from main.py
    from main import get_service
    return get_service()

# API Models for request/response validation
class HealthResponse(BaseModel):
    """Health check response model"""
    status: str = Field(..., description="Service health status")
    service: str = Field(..., description="Service name")
    timestamp: str = Field(..., description="Response timestamp")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional health details")

class OperationRequest(BaseModel):
    """Generic operation request model - customize for your needs"""
    data: Dict[str, Any] = Field(..., description="Operation data")
    options: Optional[Dict[str, Any]] = Field(None, description="Additional options")

class OperationResponse(BaseModel):
    """Generic operation response model - customize for your needs"""
    success: bool = Field(..., description="Operation success status")
    correlation_id: str = Field(..., description="Request correlation ID")
    data: Dict[str, Any] = Field(..., description="Response data")
    timestamp: str = Field(..., description="Response timestamp")
    processing_time_ms: Optional[float] = Field(None, description="Processing time in milliseconds")

# API Endpoints

@router.get("/status", response_model=HealthResponse, summary="Get service status")
async def get_service_status(
    request: Request,
    service: {{service_class}}Service = Depends(get_service)
):
    """
    Get detailed service status information.

    Returns comprehensive status including:
    - Service health
    - Initialization status
    - Connection status
    - Performance metrics
    """
    correlation_id = getattr(request.state, 'correlation_id', str(uuid.uuid4()))

    try:
        # Get service status
        service_status = await service.get_service_status()
        health_check = await service.health_check()

        status_data = {
            "status": "healthy" if health_check else "unhealthy",
            "service": "{{service_name}}",
            "timestamp": datetime.utcnow().isoformat(),
            "details": {
                "correlation_id": correlation_id,
                "service_info": service_status,
                "health_check": health_check
            }
        }

        # Audit log
        audit_data = {
            "event": "status_check_requested",
            "correlation_id": correlation_id,
            "status": status_data["status"],
            "timestamp": datetime.utcnow().isoformat()
        }
        logger.info(f"AUDIT: {json.dumps(audit_data)}")

        return HealthResponse(**status_data)

    except Exception as e:
        logger.error(f"Status check failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get service status: {str(e)}"
        )

@router.post("/operations", response_model=OperationResponse, summary="Execute business operation")
async def execute_operation(
    operation_request: OperationRequest,
    request: Request,
    service: {{service_class}}Service = Depends(get_service)
):
    """
    Execute a business operation.

    This is a template endpoint - customize it for your specific business operations.

    The endpoint demonstrates:
    - Request validation using Pydantic models
    - Correlation ID handling
    - Comprehensive audit logging
    - Error handling with proper HTTP status codes
    - Response formatting
    """
    correlation_id = getattr(request.state, 'correlation_id', str(uuid.uuid4()))
    start_time = datetime.utcnow()

    try:
        # Execute business operation
        result = await service.process_business_operation(
            operation_request.data,
            correlation_id=correlation_id
        )

        processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000

        response_data = {
            "success": True,
            "correlation_id": correlation_id,
            "data": result,
            "timestamp": datetime.utcnow().isoformat(),
            "processing_time_ms": round(processing_time, 2)
        }

        return OperationResponse(**response_data)

    except ValueError as e:
        # Business logic validation error
        logger.warning(f"Business validation error: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        # Unexpected error
        logger.error(f"Operation execution failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error occurred"
        )

@router.get("/operations/{operation_id}", summary="Get operation result")
async def get_operation_result(
    operation_id: str,
    request: Request,
    service: {{service_class}}Service = Depends(get_service)
):
    """
    Get the result of a previously executed operation.

    This is a template endpoint for retrieving operation results.
    Customize based on your specific requirements.
    """
    correlation_id = getattr(request.state, 'correlation_id', str(uuid.uuid4()))

    try:
        # TODO: Implement operation result retrieval
        # This would typically involve:
        # - Looking up operation by ID in database/cache
        # - Returning operation status and results
        # - Handling not found cases

        # Placeholder implementation
        result = {
            "operation_id": operation_id,
            "status": "completed",
            "result": {"message": "Operation completed successfully"},
            "timestamp": datetime.utcnow().isoformat()
        }

        return result

    except Exception as e:
        logger.error(f"Failed to get operation result: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve operation result"
        )

# Add more specific endpoints for your business domain
# Examples:

@router.post("/validate", summary="Validate input data")
async def validate_data(
    data: Dict[str, Any],
    request: Request,
    service: {{service_class}}Service = Depends(get_service)
):
    """
    Validate input data according to business rules.

    Customize this endpoint for your specific validation requirements.
    """
    correlation_id = getattr(request.state, 'correlation_id', str(uuid.uuid4()))

    try:
        is_valid = await service.validate_input(data)

        return {
            "valid": is_valid,
            "correlation_id": correlation_id,
            "timestamp": datetime.utcnow().isoformat()
        }

    except Exception as e:
        logger.error(f"Data validation failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Validation error occurred"
        )

# Configuration endpoint for debugging (remove in production or secure appropriately)
@router.get("/config", summary="Get service configuration", include_in_schema=False)
async def get_service_config(request: Request):
    """
    Get service configuration for debugging.

    WARNING: This endpoint should be removed in production or properly secured
    as it may expose sensitive configuration information.
    """
    from app.core.config import get_config_summary

    correlation_id = getattr(request.state, 'correlation_id', str(uuid.uuid4()))

    try:
        config_summary = get_config_summary()
        config_summary["correlation_id"] = correlation_id
        config_summary["timestamp"] = datetime.utcnow().isoformat()

        return config_summary

    except Exception as e:
        logger.error(f"Failed to get config: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve configuration"
        )

async def handle_http_exception(request: Request, exc: HTTPException):
    """Handle HTTP exceptions with proper logging"""
    correlation_id = getattr(request.state, 'correlation_id', 'unknown')

    error_data = {
        "event": "api_http_exception",
        "correlation_id": correlation_id,
        "status_code": exc.status_code,
        "detail": exc.detail,
        "path": request.url.path,
        "method": request.method,
        "timestamp": datetime.utcnow().isoformat()
    }

    logger.warning(f"API HTTP Exception: {json.dumps(error_data)}")

    return {
        "error": exc.detail,
        "correlation_id": correlation_id,
        "timestamp": datetime.utcnow().isoformat()
    }
