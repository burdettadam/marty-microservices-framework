"""
{{service_description}}

Generated FastAPI service with MMF unified observability integration.
Includes health checks, metrics, distributed tracing, and enhanced correlation ID tracking.
"""

import asyncio
import logging
import time
import uuid
from contextlib import asynccontextmanager
from datetime import datetime
from typing import Optional

import uvicorn
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import Response
from pydantic import BaseModel

# MMF imports - fail if not available
from marty_msf.monitoring import ServiceMonitor

# Enhanced unified observability imports
from marty_msf.observability.standard import create_standard_observability, get_observability
from marty_msf.observability.standard_correlation import (
    StandardCorrelationMiddleware,
    CorrelationContext,
    correlation_context,
    inject_correlation_to_span
)
# Configuration
class Config:
    """Service configuration."""
    service_name: str = "{{service_name}}"
    version: str = "{{service_version | default('0.1.0')}}"
    host: str = "0.0.0.0"
    port: int = {{service_port | default(8000)}}
    debug: bool = {{debug | default(false) | lower}}

config = Config()

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Initialize enhanced unified observability with MMF defaults
observability = create_standard_observability(
    service_name=config.service_name,
    service_version=config.version,
    service_type="fastapi"
)

# Initialize monitoring
monitor = None

# Data Models
class HealthResponse(BaseModel):
    """Health check response model."""
    service: str
    version: str
    status: str
    timestamp: str
    observability_enabled: Optional[bool] = False

class {{service_name.replace('-', '_').title()}}Request(BaseModel):
    """{{service_name}} request model."""
    data: str
    correlation_id: Optional[str] = None

class {{service_name.replace('-', '_').title()}}Response(BaseModel):
    """{{service_name}} response model."""
    id: str
    result: str
    processed_at: str
    correlation_id: str

# Application lifespan management
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application startup and shutdown."""
    global monitor, observability

    # Startup
    logger.info(f"Starting {{service_name}} v{config.version}")
    logger.info("All framework features enabled")

    # Initialize enhanced unified observability
    await observability.initialize()
    # Instrument the FastAPI app
    observability.instrument_fastapi(app)
    logger.info("Enhanced unified observability initialized and instrumented")

    # Initialize framework monitoring
    monitor = ServiceMonitor(config.service_name)
    await monitor.start()
    logger.info("Framework monitoring initialized")

    yield

    # Shutdown
    await monitor.stop()
    await observability.shutdown()
    logger.info(f"{{service_name}} shutdown complete")

# Create FastAPI application
app = FastAPI(
    title="{{service_name.replace('-', ' ').title()}}",
    description="{{service_description | default('MMF microservice with enhanced observability')}}",
    version=config.version,
    lifespan=lifespan
)

# Add observability middleware
app.add_middleware(StandardCorrelationMiddleware)

# Enhanced middleware for request tracking with correlation
@app.middleware("http")
async def track_requests(request: Request, call_next):
    """Track request metrics and handle correlation IDs with enhanced observability."""
    start_time = time.time()

    # Get correlation context from unified system
    correlation_id = CorrelationContext.get_correlation_id() or str(uuid.uuid4())
    CorrelationContext.set_correlation_id(correlation_id)

    # Process request with automatic metrics collection
    response = await call_next(request)

    # Add correlation ID to response
    response.headers["x-mmf-correlation-id"] = correlation_id

    # Metrics are automatically collected by unified observability
    # No manual metrics needed when using the enhanced system

    return response

# Core endpoints
@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Enhanced health check with framework and observability status."""
    return HealthResponse(
        service=config.service_name,
        version=config.version,
        status="healthy",
        timestamp=datetime.utcnow().isoformat(),
        observability_enabled=True
    )

@app.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint (automatically provided by unified observability)."""
    if observability:
        # Metrics are automatically exposed by standard observability
        from fastapi.responses import Response
        metrics_data = observability.get_metrics()
        return Response(metrics_data, media_type="text/plain; version=0.0.4; charset=utf-8")

@app.post("/{{service_name.replace('-', '_')}}", response_model={{service_name.replace('-', '_').title()}}Response)
async def process_{{service_name.replace('-', '_')}}(request: {{service_name.replace('-', '_').title()}}Request):
    """Process {{service_name}} request with enhanced correlation tracking."""

    # Use correlation context for enhanced tracing
    async with correlation_context(
        operation_id="process_{{service_name.replace('-', '_')}}",
        correlation_id=request.correlation_id
    ):

        # Simulate processing
        await asyncio.sleep(0.1)

        # Generate response with correlation
        correlation_id = get_correlation_id() or request.correlation_id or str(uuid.uuid4())

        response = {{service_name.replace('-', '_').title()}}Response(
            id=str(uuid.uuid4()),
            result=f"Processed: {request.data}",
            processed_at=datetime.utcnow().isoformat(),
            correlation_id=correlation_id
        )

        logger.info(f"Processed {{service_name}} request", extra={
            "correlation_id": correlation_id,
            "request_data": request.data,
            "response_id": response.id
        })

        return response

@app.get("/info")
async def service_info():
    """Service information endpoint."""
    features = [
        "Enhanced correlation tracking",
        "Health monitoring",
        "Prometheus metrics",
        "Request timing",
        "Structured logging",
        "OpenTelemetry tracing",
        "Enhanced correlation tracking",
        "Unified observability"
    ]
    else:
        features.append("Basic correlation ID tracking")

    return {
        "service": config.service_name,
        "version": config.version,
        "description": "{{service_description | default('MMF microservice')}}",
        "framework_available": True,
        "observability_enabled": True,
        "features": features
    }

# Business logic endpoints
@app.post("/process", response_model={{service_name.replace('-', '_').title()}}Response)
async def process_request(
    request: {{service_name.replace('-', '_').title()}}Request,
    http_request: Request
):
    """Process a {{service_name}} request with enhanced observability."""
    start_time = time.time()

    # Get correlation ID from unified system
    correlation_id = get_correlation_id() or str(uuid.uuid4())

    # Use correlation context for tracing
    with with_correlation(
        operation_name="process_request",
        correlation_id=correlation_id,
        result_id=str(uuid.uuid4())
        ):
            try:
                # Business logic here
                result_id = str(uuid.uuid4())
                result = f"Processed: {request.data}"

                # Enhanced logging with correlation context
                logger.info(
                    "Processed request successfully",
                    extra={
                        "correlation_id": correlation_id,
                        "result_id": result_id,
                        "processing_time": time.time() - start_time,
                        "operation": "process_request"
                    }
                )

                return {{service_name.replace('-', '_').title()}}Response(
                    id=result_id,
                    result=result,
                    processed_at=datetime.utcnow().isoformat(),
                    correlation_id=correlation_id
                )

            except Exception as e:
                logger.error(
                    f"Processing failed: {e}",
                    extra={
                        "correlation_id": correlation_id,
                        "operation": "process_request",
                        "error": str(e)
                    }
                )
                raise HTTPException(status_code=500, detail="Processing failed")
    else:
        # Fallback to manual correlation handling
        correlation_id = request.correlation_id or getattr(http_request.state, 'correlation_id', str(uuid.uuid4()))

        try:
            # Business logic here
            result_id = str(uuid.uuid4())
            result = f"Processed: {request.data}"

            # Log the operation
            logger.info(
                "Processed request successfully",
                extra={
                    "correlation_id": correlation_id,
                    "result_id": result_id,
                    "processing_time": time.time() - start_time
                }
            )

            return {{service_name.replace('-', '_').title()}}Response(
                id=result_id,
                result=result,
                processed_at=datetime.utcnow().isoformat(),
                correlation_id=correlation_id
            )

        except Exception as e:
            logger.error(
                f"Processing failed: {e}",
                extra={"correlation_id": correlation_id}
            )
            raise HTTPException(status_code=500, detail="Processing failed")

@app.get("/status")
async def service_status():
    """Detailed service status with observability information."""
    return {
        "service": config.service_name,
        "status": "running",
        "uptime": "N/A",  # Would calculate from startup time in production
        "framework": {
            "available": True,
            "monitoring_active": monitor is not None
        },
        "observability": {
            "unified_available": True,
            "tracing_enabled": observability is not None and observability.tracer is not None if observability else False,
            "metrics_enabled": observability is not None and observability.meter is not None if observability else False
        },
        "metrics": {
            "requests_handled": "See /metrics endpoint",
            "average_response_time": "See /metrics endpoint"
        }
    }

# Development and testing endpoints
@app.get("/")
async def root():
    """Root endpoint with service information."""
    return {
        "message": f"{{service_name.replace('-', ' ').title()}} is running",
        "version": config.version,
        "health": "/health",
        "metrics": "/metrics",
        "info": "/info",
        "docs": "/docs",
        "framework_integrated": True,
        "observability_enabled": True
    }

if __name__ == "__main__":
    # Run the service
    logger.info(f"Starting {{service_name}} on {config.host}:{config.port}")

    uvicorn.run(
        app,
        host=config.host,
        port=config.port,
        log_level="info" if not config.debug else "debug"
    )
