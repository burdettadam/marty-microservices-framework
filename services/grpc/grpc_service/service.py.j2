"""
{{service_class}} gRPC service implementation.

This service implements the {{service_name}} gRPC interface using enterprise patterns:
- Repository pattern for data access
- Event-driven architecture with Phase 2 components
- Configuration management with secrets
- Multi-backend caching infrastructure
- Message queues and event streaming
- API Gateway integration
- Comprehensive monitoring and health checks
- Distributed tracing
"""

import logging
from typing import Any, Optional

import grpc
from grpc_health.v1 import health_pb2

from marty_msf.framework.config import UnifiedConfigurationManager
from marty_msf.framework.secrets import UnifiedSecrets
from marty_msf.observability.standard_correlation import CorrelationContext
from src.framework.observability.monitoring import ServiceMonitor, time_operation
{% if use_database %}
from marty_msf.framework.database import DatabaseManager, UnitOfWork
from src.framework.events import EventBus, publish_system_event
{% endif %}

# Import your protobuf message types here
# from src.proto.{{service_package}}_pb2 import (
#     ProcessRequest,
#     ProcessResponse,
#     StatusRequest,
#     StatusResponse,
# )
# from src.proto.{{service_package}}_pb2_grpc import {{service_class}}Servicer

logger = logging.getLogger(__name__)
class {{service_class}}Service:  # Implement your gRPC servicer interface here
    """
    Implementation of the {{service_class}} gRPC service.

    This service handles {{(service_description or "service functionality").lower()}}
    using unified enterprise infrastructure:
    - Unified configuration and secrets management
    - Standard observability with correlation
    - Database management (if enabled)
    - Event-driven architecture
    """

    def __init__(
        self,
        config_manager: UnifiedConfigurationManager,
        secrets_manager: UnifiedSecrets,
        {% if use_database %}
        db_manager: Optional[DatabaseManager] = None,
        event_bus: Optional[EventBus] = None,
        {% endif %}
        monitor: Optional[ServiceMonitor] = None,
    ) -> None:
        """Initialize the {{service_class}} service with unified infrastructure."""
        logger.info("Initializing {{service_class}} Service with unified infrastructure")

        # Unified components
        self.config_manager = config_manager
        self.secrets_manager = secrets_manager

        # Service monitoring
        service_name = config_manager.get("service.name", "{{service_name}}")
        self.monitor = monitor or ServiceMonitor(service_name)

        {% if use_database %}
        # Database and events (if enabled)
        self.db_manager = db_manager
        self.event_bus = event_bus
        {% endif %}

        logger.info(f"{{service_class}} Service initialized successfully")

    def GetStatus(self, request, context):
        """
        Get service status.

        Args:
            request: The status request
            context: gRPC context

        Returns:
            Status response with service health information
        """
        logger.info("Received status request")

        # Implement your status check logic here
        # Return appropriate status response
        pass

    # Add your gRPC method implementations here
    # Example method demonstrating Phase 2 infrastructure:
    async def ProcessData(self, request: Any, context: grpc.ServicerContext) -> Any:
        """Process data with Phase 2 enterprise patterns."""
        request_id = getattr(request, 'id', 'unknown')

        with traced_operation("process_data", request_id=request_id) as span:
            try:
                # Phase 2: Check cache first
                cache_key = f"processed_data:{request_id}"
                cached_result = await self.cache_manager.get(cache_key)
                if cached_result:
                    span.set_attribute("cache_hit", True)
                    return cached_result

                # Phase 2: Get dynamic configuration
                processing_config = await self.config_manager.get_config(
                    "processing_settings",
                    {"max_retries": 3, "timeout": 30}
                )

                # Phase 2: Get secrets for external API calls
                api_key = await self.secret_manager.get_secret("external_api_key")

                {% if use_database %}
                # Use repository pattern for data access
                async with UnitOfWork(self.db_manager) as uow:
                    # repository = uow.get_repository(YourModel)

                    # Your business logic here
                    # result = await repository.create(entity)

                    # Phase 2: Publish to event stream for CQRS
                    await self.event_stream_manager.publish_event(
                        stream_name=f"{{service_name}}-events",
                        event_type="DataProcessed",
                        event_data={
                            "request_id": request_id,
                            "timestamp": span.get_attribute("start_time"),
                            "service": "{{service_name}}",
                        }
                    )

                    # Publish domain event via message queue
                    await self.message_queue.publish(
                        queue_name="{{service_name}}.events",
                        message={
                            "event_type": "data_processed",
                            "request_id": request_id,
                            "source": "{{service_name}}",
                        }
                    )

                    await uow.commit()
                {% else %}
                # Phase 2: Publish events even without database
                await self.event_stream_manager.publish_event(
                    stream_name=f"{{service_name}}-events",
                    event_type="DataProcessed",
                    event_data={
                        "request_id": request_id,
                        "timestamp": span.get_attribute("start_time"),
                        "service": "{{service_name}}",
                    }
                )

                await self.message_queue.publish(
                    queue_name="{{service_name}}.events",
                    message={
                        "event_type": "data_processed",
                        "request_id": request_id,
                        "source": "{{service_name}}",
                    }
                )
                {% endif %}

                # Process the data (your business logic here)
                result = {"status": "processed", "request_id": request_id}

                # Phase 2: Cache the result
                await self.cache_manager.set(
                    cache_key,
                    result,
                    ttl=self.config.cache_ttl
                )

                # Record metrics
                if self.monitor:
                    self.monitor.metrics.counter("data_processed_total")

                span.set_attribute("success", True)
                span.set_attribute("cache_hit", False)

                # Return your response
                # return ProcessResponse(...)
                return result

            except Exception as e:
                logger.error("Error processing data: %s", e)
                span.record_exception(e)

                # Record error metrics
                if self.monitor:
                    self.monitor.metrics.counter("data_processing_errors_total")

                await context.abort(grpc.StatusCode.INTERNAL, f"Processing failed: {e}")


# Health check implementations with Phase 2 infrastructure
def create_health_checks(service: {{service_class}}Service) -> dict:
    """Create health check functions for the service with Phase 2 components."""

    def service_health() -> bool:
        """Check if service is healthy."""
        return True  # Implement your health check logic

    async def cache_health() -> bool:
        """Check cache connectivity."""
        try:
            await service.cache_manager.set("health_check", "ok", ttl=5)
            result = await service.cache_manager.get("health_check")
            return result == "ok"
        except Exception:
            return False

    async def message_queue_health() -> bool:
        """Check message queue connectivity."""
        try:
            return await service.message_queue.health_check()
        except Exception:
            return False

    async def event_stream_health() -> bool:
        """Check event stream connectivity."""
        try:
            return await service.event_stream_manager.health_check()
        except Exception:
            return False

    async def api_gateway_health() -> bool:
        """Check API gateway connectivity."""
        try:
            return await service.api_gateway.health_check()
        except Exception:
            return False

    {% if use_database %}
    async def database_health() -> bool:
        """Check database connectivity."""
        return await service.db_manager.health_check()
    {% endif %}

    return {
        "service": service_health,
        "cache": cache_health,
        "message_queue": message_queue_health,
        "event_stream": event_stream_health,
        "api_gateway": api_gateway_health,
        {% if use_database %}
        "database": database_health,
        {% endif %}
    }
