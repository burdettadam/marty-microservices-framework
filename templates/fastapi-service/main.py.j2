"""
{{project_description}}

A FastAPI microservice built with the Marty framework.

Author: {{author_name}}
Email: {{author_email}}
"""

import asyncio
import os
from contextlib import asynccontextmanager
from datetime import datetime
from typing import Dict, Any, Optional, List

import uvicorn
from fastapi import FastAPI, HTTPException, Depends, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import structlog
from prometheus_client import Counter, Histogram, Gauge, generate_latest, CONTENT_TYPE_LATEST

# Configure structured logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

# Metrics - avoid duplicate registration
from prometheus_client import REGISTRY, CollectorRegistry

# Create or get existing metrics
try:
    request_count = Counter(
        'http_requests_total',
        'Total HTTP requests',
        ['method', 'endpoint', 'status_code']
    )
except ValueError:
    # Metric already exists - this happens on hot reload
    request_count = None

try:
    request_duration = Histogram(
        'http_request_duration_seconds',
        'HTTP request duration in seconds',
        ['method', 'endpoint']
    )
except ValueError:
    request_duration = None

try:
    active_connections = Gauge(
        'active_connections',
        'Number of active connections'
    )
except ValueError:
    active_connections = None


# Pydantic models
class HealthResponse(BaseModel):
    """Health check response model."""
    status: str = "healthy"
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    version: str = "{{framework_version}}"
    service: str = "{{project_slug}}"


class ErrorResponse(BaseModel):
    """Error response model."""
    error: str
    message: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    trace_id: Optional[str] = None


# Application lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan management."""
    logger.info("Starting {{project_name}}")

    # Startup logic
    yield

    # Shutdown logic
    logger.info("Shutting down {{project_name}}")


# Create FastAPI application
app = FastAPI(
    title="{{project_name}}",
    description="{{project_description}}",
    version="1.0.0",
    docs_url="/docs" if {{enable_docs}} else None,
    redoc_url="/redoc" if {{enable_docs}} else None,
    lifespan=lifespan
)

# Add middleware
{% if enable_cors %}
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
{% endif %}

app.add_middleware(GZipMiddleware, minimum_size=1000)


# Middleware for metrics
@app.middleware("http")
async def metrics_middleware(request: Request, call_next):
    """Collect request metrics."""
    method = request.method
    path_template = request.url.path

    # Track active connections
    if active_connections:
        active_connections.inc()

    # Start timer
    if request_duration:
        with request_duration.labels(method=method, endpoint=path_template).time():
            response = await call_next(request)
    else:
        response = await call_next(request)

    # Record metrics
    if request_count:
        request_count.labels(
            method=method,
            endpoint=path_template,
            status_code=response.status_code
        ).inc()

    if active_connections:
        active_connections.dec()

    return response


# Exception handlers
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Handle HTTP exceptions."""
    logger.warning(
        "HTTP exception occurred",
        status_code=exc.status_code,
        detail=exc.detail,
        path=request.url.path
    )

    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error=f"HTTP {exc.status_code}",
            message=str(exc.detail)
        ).dict()
    )


@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """Handle general exceptions."""
    logger.error(
        "Unexpected error occurred",
        error=str(exc),
        path=request.url.path,
        exc_info=True
    )

    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            error="Internal Server Error",
            message="An unexpected error occurred"
        ).dict()
    )


# Routes
{% if enable_health_checks %}
@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check endpoint."""
    return HealthResponse()


@app.get("/ready", response_model=HealthResponse)
async def readiness_check():
    """Readiness check endpoint."""
    # Add any readiness checks here (database connections, etc.)
    return HealthResponse(status="ready")
{% endif %}

{% if enable_monitoring %}
@app.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint."""
    return Response(content=generate_latest(), media_type=CONTENT_TYPE_LATEST)
{% endif %}


@app.get("/")
async def root():
    """Root endpoint."""
    return {
        "service": "{{project_slug}}",
        "version": "1.0.0",
        "description": "{{project_description}}",
        "docs_url": "/docs" if {{enable_docs}} else None
    }


# Example API endpoints
@app.get("/api/status")
async def get_status():
    """Get service status."""
    return {
        "status": "running",
        "service": "{{project_slug}}",
        "timestamp": datetime.utcnow().isoformat()
    }


# Add your custom endpoints here
# Example:
# @app.get("/api/items")
# async def list_items():
#     """List items."""
#     return {"items": []}


if __name__ == "__main__":
    # Configuration
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "{{service_port}}"))
    debug = os.getenv("DEBUG", "false").lower() == "true"

    logger.info(
        "Starting server",
        host=host,
        port=port,
        debug=debug,
        environment="{{environment}}"
    )

    uvicorn.run(
        "main:app",
        host=host,
        port=port,
        reload=debug,
        log_level="debug" if debug else "info"
    )
