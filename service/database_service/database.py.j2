"""
Database connection management and configuration.
"""

from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import QueuePool
from sqlalchemy.exc import SQLAlchemyError, DisconnectionError
from contextlib import contextmanager, asynccontextmanager
from typing import Generator, AsyncGenerator, Optional
import asyncio
import logging
from datetime import datetime
import time

logger = logging.getLogger(__name__)


class DatabaseManager:
    """Manages database connections and transactions."""

    def __init__(self, database_url: str, **engine_kwargs):
        """
        Initialize database manager.

        Args:
            database_url: PostgreSQL connection URL
            **engine_kwargs: Additional SQLAlchemy engine parameters
        """
        self.database_url = database_url
        self.engine = None
        self.SessionLocal = None
        self._engine_kwargs = engine_kwargs

    async def initialize(self):
        """Initialize database engine and session factory."""
        engine_config = {
            'poolclass': QueuePool,
            'pool_size': self._engine_kwargs.get('pool_size', 10),
            'max_overflow': self._engine_kwargs.get('max_overflow', 20),
            'pool_timeout': self._engine_kwargs.get('pool_timeout', 30),
            'pool_recycle': self._engine_kwargs.get('pool_recycle', 3600),
            'pool_pre_ping': True,  # Enables automatic reconnection
            'echo': self._engine_kwargs.get('log_sql_queries', False),
        }

        self.engine = create_engine(self.database_url, **engine_config)

        # Add event listeners for connection management
        event.listen(self.engine, "connect", self._on_connect)
        event.listen(self.engine, "checkout", self._on_checkout)
        event.listen(self.engine, "checkin", self._on_checkin)

        self.SessionLocal = sessionmaker(
            autocommit=False,
            autoflush=False,
            bind=self.engine
        )

        logger.info("Database manager initialized successfully")

    def _on_connect(self, dbapi_connection, connection_record):
        """Called when a new database connection is created."""
        connection_record.info['connect_time'] = time.time()
        logger.debug("New database connection established")

    def _on_checkout(self, dbapi_connection, connection_record, connection_proxy):
        """Called when a connection is retrieved from the pool."""
        connection_record.info['checkout_time'] = time.time()

    def _on_checkin(self, dbapi_connection, connection_record):
        """Called when a connection is returned to the pool."""
        if 'checkout_time' in connection_record.info:
            checkout_time = connection_record.info['checkout_time']
            usage_time = time.time() - checkout_time
            logger.debug(f"Connection returned to pool after {usage_time:.2f}s")

    @contextmanager
    def get_session(self) -> Generator[Session, None, None]:
        """
        Context manager for database sessions.

        Yields:
            Database session
        """
        if not self.SessionLocal:
            raise RuntimeError("Database manager not initialized")

        session = self.SessionLocal()
        try:
            yield session
            session.commit()
        except Exception as e:
            session.rollback()
            logger.error(f"Database session error: {e}")
            raise
        finally:
            session.close()

    @contextmanager
    def get_transaction(self, session: Optional[Session] = None) -> Generator[Session, None, None]:
        """
        Context manager for database transactions.

        Args:
            session: Optional existing session to use

        Yields:
            Database session within a transaction
        """
        if session:
            # Use existing session, create savepoint
            savepoint = session.begin_nested()
            try:
                yield session
                savepoint.commit()
            except Exception as e:
                savepoint.rollback()
                logger.error(f"Transaction rolled back: {e}")
                raise
        else:
            # Create new session and transaction
            with self.get_session() as sess:
                yield sess

    async def health_check(self, timeout: int = 5) -> bool:
        """
        Check database connectivity.

        Args:
            timeout: Health check timeout in seconds

        Returns:
            True if database is healthy, False otherwise
        """
        try:
            with self.get_session() as session:
                # Simple query to test connectivity
                result = session.execute("SELECT 1").scalar()
                return result == 1
        except Exception as e:
            logger.error(f"Database health check failed: {e}")
            return False

    def get_connection_info(self) -> dict:
        """
        Get database connection information.

        Returns:
            Dictionary with connection details
        """
        if not self.engine:
            return {"status": "not_initialized"}

        pool = self.engine.pool
        return {
            "status": "initialized",
            "pool_size": pool.size(),
            "checked_in": pool.checkedin(),
            "checked_out": pool.checkedout(),
            "overflow": pool.overflow(),
            "invalid": pool.invalid()
        }

    async def close(self):
        """Close database connections."""
        if self.engine:
            self.engine.dispose()
            logger.info("Database connections closed")


# Global database manager instance
_db_manager: Optional[DatabaseManager] = None

def get_database_manager() -> DatabaseManager:
    """Get the global database manager instance."""
    global _db_manager
    if not _db_manager:
        raise RuntimeError("Database manager not initialized")
    return _db_manager

def set_database_manager(manager: DatabaseManager):
    """Set the global database manager instance."""
    global _db_manager
    _db_manager = manager

# Legacy support - create engine directly
engine = None

def initialize_engine(database_url: str, **kwargs):
    """Initialize the global engine (legacy support)."""
    global engine
    manager = DatabaseManager(database_url, **kwargs)
    asyncio.create_task(manager.initialize())
    engine = manager.engine
    set_database_manager(manager)
