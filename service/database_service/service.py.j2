"""
{{service_name}} gRPC service implementation with database operations.
"""

import grpc
from typing import AsyncIterator
import logging

from marty_common.grpc_service_factory import BaseGRPCService
from marty_common.status_factory import create_status, StatusCode

from src.{{service_package}}.app.core.database import get_database_manager
from src.{{service_package}}.app.repositories import (
    get_entity_repository,
    get_attribute_repository,
    get_audit_repository
)

# Import generated protobuf
from src.{{service_package}}.proto import {{service_package}}_pb2, {{service_package}}_pb2_grpc

logger = logging.getLogger(__name__)


class {{service_class}}Service({{service_package}}_pb2_grpc.{{service_class}}ServiceServicer, BaseGRPCService):
    """{{service_description}}"""

    def __init__(self):
        """Initialize the service."""
        super().__init__()
        self.db_manager = get_database_manager()
        self.entity_repo = get_entity_repository()
        self.attribute_repo = get_attribute_repository()
        self.audit_repo = get_audit_repository()

    async def CreateEntity(
        self,
        request: {{service_package}}_pb2.CreateEntityRequest,
        context: grpc.aio.ServicerContext
    ) -> {{service_package}}_pb2.CreateEntityResponse:
        """Create a new entity."""
        try:
            with self.db_manager.get_transaction() as session:
                # Create the entity
                entity = self.entity_repo.create(
                    session=session,
                    name=request.name,
                    description=request.description,
                    external_id=request.external_id if request.external_id else None,
                    status=request.status if request.status else "active",
                    metadata_=request.metadata if request.metadata else None
                )

                # Create attributes if provided
                for attr in request.attributes:
                    self.attribute_repo.create(
                        session=session,
                        entity_id=entity.id,
                        attribute_name=attr.name,
                        attribute_value=attr.value,
                        attribute_type=attr.type if attr.type else "string"
                    )

                # Log the creation
                self.audit_repo.log_change(
                    session=session,
                    entity_id=entity.id,
                    entity_type="{{service_class}}Entity",
                    action="CREATE",
                    new_values={
                        "name": entity.name,
                        "description": entity.description,
                        "status": entity.status
                    },
                    user_id=self._get_user_id(context),
                    session_id=self._get_session_id(context),
                    ip_address=self._get_client_ip(context),
                    user_agent=self._get_user_agent(context)
                )

                return {{service_package}}_pb2.CreateEntityResponse(
                    entity_id=entity.id,
                    status=create_status(StatusCode.OK, "Entity created successfully")
                )

        except Exception as e:
            logger.error(f"Error creating entity: {e}", exc_info=True)
            return {{service_package}}_pb2.CreateEntityResponse(
                status=create_status(StatusCode.INTERNAL, f"Failed to create entity: {str(e)}")
            )

    async def GetEntity(
        self,
        request: {{service_package}}_pb2.GetEntityRequest,
        context: grpc.aio.ServicerContext
    ) -> {{service_package}}_pb2.GetEntityResponse:
        """Get entity by ID."""
        try:
            with self.db_manager.get_session() as session:
                entity = self.entity_repo.get_by_id(session, request.entity_id)

                if not entity:
                    return {{service_package}}_pb2.GetEntityResponse(
                        status=create_status(StatusCode.NOT_FOUND, "Entity not found")
                    )

                # Get attributes
                attributes = self.attribute_repo.get_by_entity_id(session, entity.id)

                # Build response
                entity_proto = {{service_package}}_pb2.Entity(
                    id=entity.id,
                    name=entity.name,
                    description=entity.description or "",
                    external_id=entity.external_id or "",
                    status=entity.status,
                    metadata=entity.metadata_ or "",
                    created_at=entity.created_at.isoformat(),
                    updated_at=entity.updated_at.isoformat()
                )

                for attr in attributes:
                    entity_proto.attributes.append(
                        {{service_package}}_pb2.EntityAttribute(
                            name=attr.attribute_name,
                            value=attr.attribute_value or "",
                            type=attr.attribute_type
                        )
                    )

                return {{service_package}}_pb2.GetEntityResponse(
                    entity=entity_proto,
                    status=create_status(StatusCode.OK, "Entity retrieved successfully")
                )

        except Exception as e:
            logger.error(f"Error getting entity {request.entity_id}: {e}", exc_info=True)
            return {{service_package}}_pb2.GetEntityResponse(
                status=create_status(StatusCode.INTERNAL, f"Failed to get entity: {str(e)}")
            )

    async def UpdateEntity(
        self,
        request: {{service_package}}_pb2.UpdateEntityRequest,
        context: grpc.aio.ServicerContext
    ) -> {{service_package}}_pb2.UpdateEntityResponse:
        """Update an existing entity."""
        try:
            with self.db_manager.get_transaction() as session:
                # Get current entity for audit trail
                current_entity = self.entity_repo.get_by_id(session, request.entity_id)
                if not current_entity:
                    return {{service_package}}_pb2.UpdateEntityResponse(
                        status=create_status(StatusCode.NOT_FOUND, "Entity not found")
                    )

                # Store old values for audit
                old_values = {
                    "name": current_entity.name,
                    "description": current_entity.description,
                    "status": current_entity.status,
                    "metadata": current_entity.metadata_
                }

                # Update entity
                update_fields = {}
                if request.HasField("name"):
                    update_fields["name"] = request.name
                if request.HasField("description"):
                    update_fields["description"] = request.description
                if request.HasField("status"):
                    update_fields["status"] = request.status
                if request.HasField("metadata"):
                    update_fields["metadata_"] = request.metadata

                updated_entity = self.entity_repo.update(
                    session=session,
                    entity_id=request.entity_id,
                    **update_fields
                )

                if not updated_entity:
                    return {{service_package}}_pb2.UpdateEntityResponse(
                        status=create_status(StatusCode.NOT_FOUND, "Entity not found")
                    )

                # Log the update
                new_values = {
                    "name": updated_entity.name,
                    "description": updated_entity.description,
                    "status": updated_entity.status,
                    "metadata": updated_entity.metadata_
                }

                self.audit_repo.log_change(
                    session=session,
                    entity_id=updated_entity.id,
                    entity_type="{{service_class}}Entity",
                    action="UPDATE",
                    old_values=old_values,
                    new_values=new_values,
                    user_id=self._get_user_id(context),
                    session_id=self._get_session_id(context),
                    ip_address=self._get_client_ip(context),
                    user_agent=self._get_user_agent(context)
                )

                return {{service_package}}_pb2.UpdateEntityResponse(
                    status=create_status(StatusCode.OK, "Entity updated successfully")
                )

        except Exception as e:
            logger.error(f"Error updating entity {request.entity_id}: {e}", exc_info=True)
            return {{service_package}}_pb2.UpdateEntityResponse(
                status=create_status(StatusCode.INTERNAL, f"Failed to update entity: {str(e)}")
            )

    async def DeleteEntity(
        self,
        request: {{service_package}}_pb2.DeleteEntityRequest,
        context: grpc.aio.ServicerContext
    ) -> {{service_package}}_pb2.DeleteEntityResponse:
        """Delete an entity (soft delete by default)."""
        try:
            with self.db_manager.get_transaction() as session:
                success = self.entity_repo.delete(
                    session=session,
                    entity_id=request.entity_id,
                    soft_delete=not request.hard_delete
                )

                if not success:
                    return {{service_package}}_pb2.DeleteEntityResponse(
                        status=create_status(StatusCode.NOT_FOUND, "Entity not found")
                    )

                # Log the deletion
                self.audit_repo.log_change(
                    session=session,
                    entity_id=request.entity_id,
                    entity_type="{{service_class}}Entity",
                    action="DELETE",
                    new_values={"hard_delete": request.hard_delete},
                    user_id=self._get_user_id(context),
                    session_id=self._get_session_id(context),
                    ip_address=self._get_client_ip(context),
                    user_agent=self._get_user_agent(context)
                )

                return {{service_package}}_pb2.DeleteEntityResponse(
                    status=create_status(StatusCode.OK, "Entity deleted successfully")
                )

        except Exception as e:
            logger.error(f"Error deleting entity {request.entity_id}: {e}", exc_info=True)
            return {{service_package}}_pb2.DeleteEntityResponse(
                status=create_status(StatusCode.INTERNAL, f"Failed to delete entity: {str(e)}")
            )

    async def ListEntities(
        self,
        request: {{service_package}}_pb2.ListEntitiesRequest,
        context: grpc.aio.ServicerContext
    ) -> {{service_package}}_pb2.ListEntitiesResponse:
        """List entities with pagination."""
        try:
            with self.db_manager.get_session() as session:
                entities = self.entity_repo.get_all(
                    session=session,
                    skip=request.skip,
                    limit=min(request.limit, 1000) if request.limit > 0 else 100
                )

                total_count = self.entity_repo.count(session)

                # Build response
                entity_list = []
                for entity in entities:
                    entity_proto = {{service_package}}_pb2.Entity(
                        id=entity.id,
                        name=entity.name,
                        description=entity.description or "",
                        external_id=entity.external_id or "",
                        status=entity.status,
                        metadata=entity.metadata_ or "",
                        created_at=entity.created_at.isoformat(),
                        updated_at=entity.updated_at.isoformat()
                    )
                    entity_list.append(entity_proto)

                return {{service_package}}_pb2.ListEntitiesResponse(
                    entities=entity_list,
                    total_count=total_count,
                    status=create_status(StatusCode.OK, f"Retrieved {len(entities)} entities")
                )

        except Exception as e:
            logger.error(f"Error listing entities: {e}", exc_info=True)
            return {{service_package}}_pb2.ListEntitiesResponse(
                status=create_status(StatusCode.INTERNAL, f"Failed to list entities: {str(e)}")
            )

    async def SearchEntities(
        self,
        request: {{service_package}}_pb2.SearchEntitiesRequest,
        context: grpc.aio.ServicerContext
    ) -> {{service_package}}_pb2.SearchEntitiesResponse:
        """Search entities by query."""
        try:
            with self.db_manager.get_session() as session:
                entities = self.entity_repo.search(
                    session=session,
                    query=request.query,
                    limit=min(request.limit, 1000) if request.limit > 0 else 50
                )

                # Build response
                entity_list = []
                for entity in entities:
                    entity_proto = {{service_package}}_pb2.Entity(
                        id=entity.id,
                        name=entity.name,
                        description=entity.description or "",
                        external_id=entity.external_id or "",
                        status=entity.status,
                        metadata=entity.metadata_ or "",
                        created_at=entity.created_at.isoformat(),
                        updated_at=entity.updated_at.isoformat()
                    )
                    entity_list.append(entity_proto)

                return {{service_package}}_pb2.SearchEntitiesResponse(
                    entities=entity_list,
                    status=create_status(StatusCode.OK, f"Found {len(entities)} entities")
                )

        except Exception as e:
            logger.error(f"Error searching entities: {e}", exc_info=True)
            return {{service_package}}_pb2.SearchEntitiesResponse(
                status=create_status(StatusCode.INTERNAL, f"Failed to search entities: {str(e)}")
            )

    async def HealthCheck(
        self,
        request: {{service_package}}_pb2.HealthCheckRequest,
        context: grpc.aio.ServicerContext
    ) -> {{service_package}}_pb2.HealthCheckResponse:
        """Health check with database connectivity."""
        try:
            # Check database health
            db_healthy = await self.db_manager.health_check()

            if db_healthy:
                return {{service_package}}_pb2.HealthCheckResponse(
                    status="SERVING",
                    database_status="HEALTHY",
                    connection_info=str(self.db_manager.get_connection_info())
                )
            else:
                return {{service_package}}_pb2.HealthCheckResponse(
                    status="NOT_SERVING",
                    database_status="UNHEALTHY",
                    connection_info=str(self.db_manager.get_connection_info())
                )

        except Exception as e:
            logger.error(f"Health check error: {e}", exc_info=True)
            return {{service_package}}_pb2.HealthCheckResponse(
                status="NOT_SERVING",
                database_status="ERROR",
                connection_info=f"Error: {str(e)}"
            )

    def _get_user_id(self, context: grpc.aio.ServicerContext) -> str:
        """Extract user ID from gRPC context."""
        metadata = dict(context.invocation_metadata())
        return metadata.get("user-id", "unknown")

    def _get_session_id(self, context: grpc.aio.ServicerContext) -> str:
        """Extract session ID from gRPC context."""
        metadata = dict(context.invocation_metadata())
        return metadata.get("session-id", "unknown")

    def _get_client_ip(self, context: grpc.aio.ServicerContext) -> str:
        """Extract client IP from gRPC context."""
        return context.peer()

    def _get_user_agent(self, context: grpc.aio.ServicerContext) -> str:
        """Extract user agent from gRPC context."""
        metadata = dict(context.invocation_metadata())
        return metadata.get("user-agent", "unknown")
