"""
Repository pattern implementation for {{service_name}}.
"""

from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any, Generic, TypeVar, Type
from sqlalchemy.orm import Session, Query
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import and_, or_, desc, asc, func
from datetime import datetime
import logging
import json

from src.{{service_package}}.app.models import BaseModel, {{service_class}}Entity, {{service_class}}Attribute, {{service_class}}AuditLog
from src.{{service_package}}.app.core.database import DatabaseManager, get_database_manager

logger = logging.getLogger(__name__)

T = TypeVar('T', bound=BaseModel)


class BaseRepository(ABC, Generic[T]):
    """Base repository with common CRUD operations."""

    def __init__(self, model_class: Type[T], db_manager: DatabaseManager):
        """
        Initialize repository.

        Args:
            model_class: SQLAlchemy model class
            db_manager: Database manager instance
        """
        self.model_class = model_class
        self.db_manager = db_manager

    def create(self, session: Session, **kwargs) -> T:
        """
        Create a new entity.

        Args:
            session: Database session
            **kwargs: Entity attributes

        Returns:
            Created entity
        """
        try:
            entity = self.model_class(**kwargs)
            session.add(entity)
            session.flush()  # Get ID without committing
            logger.info(f"Created {self.model_class.__name__} with ID: {entity.id}")
            return entity
        except SQLAlchemyError as e:
            logger.error(f"Error creating {self.model_class.__name__}: {e}")
            raise

    def get_by_id(self, session: Session, entity_id: int) -> Optional[T]:
        """
        Get entity by ID.

        Args:
            session: Database session
            entity_id: Entity ID

        Returns:
            Entity or None if not found
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.id == entity_id,
                self.model_class.is_active == True
            ).first()
        except SQLAlchemyError as e:
            logger.error(f"Error getting {self.model_class.__name__} by ID {entity_id}: {e}")
            raise

    def get_all(self, session: Session, skip: int = 0, limit: int = 100) -> List[T]:
        """
        Get all entities with pagination.

        Args:
            session: Database session
            skip: Number of records to skip
            limit: Maximum number of records to return

        Returns:
            List of entities
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.is_active == True
            ).offset(skip).limit(limit).all()
        except SQLAlchemyError as e:
            logger.error(f"Error getting all {self.model_class.__name__}: {e}")
            raise

    def update(self, session: Session, entity_id: int, **kwargs) -> Optional[T]:
        """
        Update entity by ID.

        Args:
            session: Database session
            entity_id: Entity ID
            **kwargs: Fields to update

        Returns:
            Updated entity or None if not found
        """
        try:
            entity = self.get_by_id(session, entity_id)
            if not entity:
                return None

            for key, value in kwargs.items():
                if hasattr(entity, key):
                    setattr(entity, key, value)

            entity.updated_at = datetime.utcnow()
            session.flush()
            logger.info(f"Updated {self.model_class.__name__} ID: {entity_id}")
            return entity
        except SQLAlchemyError as e:
            logger.error(f"Error updating {self.model_class.__name__} ID {entity_id}: {e}")
            raise

    def delete(self, session: Session, entity_id: int, soft_delete: bool = True) -> bool:
        """
        Delete entity by ID.

        Args:
            session: Database session
            entity_id: Entity ID
            soft_delete: If True, mark as inactive instead of deleting

        Returns:
            True if deleted, False if not found
        """
        try:
            entity = self.get_by_id(session, entity_id)
            if not entity:
                return False

            if soft_delete:
                entity.is_active = False
                entity.updated_at = datetime.utcnow()
            else:
                session.delete(entity)

            session.flush()
            logger.info(f"Deleted {self.model_class.__name__} ID: {entity_id} (soft: {soft_delete})")
            return True
        except SQLAlchemyError as e:
            logger.error(f"Error deleting {self.model_class.__name__} ID {entity_id}: {e}")
            raise

    def count(self, session: Session) -> int:
        """
        Count active entities.

        Args:
            session: Database session

        Returns:
            Number of active entities
        """
        try:
            return session.query(func.count(self.model_class.id)).filter(
                self.model_class.is_active == True
            ).scalar()
        except SQLAlchemyError as e:
            logger.error(f"Error counting {self.model_class.__name__}: {e}")
            raise


class {{service_class}}EntityRepository(BaseRepository[{{service_class}}Entity]):
    """Repository for {{service_name}} entities."""

    def __init__(self, db_manager: DatabaseManager):
        super().__init__({{service_class}}Entity, db_manager)

    def get_by_name(self, session: Session, name: str) -> Optional[{{service_class}}Entity]:
        """
        Get entity by name.

        Args:
            session: Database session
            name: Entity name

        Returns:
            Entity or None if not found
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.name == name,
                self.model_class.is_active == True
            ).first()
        except SQLAlchemyError as e:
            logger.error(f"Error getting entity by name '{name}': {e}")
            raise

    def get_by_external_id(self, session: Session, external_id: str) -> Optional[{{service_class}}Entity]:
        """
        Get entity by external ID.

        Args:
            session: Database session
            external_id: External ID

        Returns:
            Entity or None if not found
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.external_id == external_id,
                self.model_class.is_active == True
            ).first()
        except SQLAlchemyError as e:
            logger.error(f"Error getting entity by external ID '{external_id}': {e}")
            raise

    def search(self, session: Session, query: str, limit: int = 50) -> List[{{service_class}}Entity]:
        """
        Search entities by name or description.

        Args:
            session: Database session
            query: Search query
            limit: Maximum number of results

        Returns:
            List of matching entities
        """
        try:
            search_pattern = f"%{query}%"
            return session.query(self.model_class).filter(
                and_(
                    self.model_class.is_active == True,
                    or_(
                        self.model_class.name.ilike(search_pattern),
                        self.model_class.description.ilike(search_pattern)
                    )
                )
            ).limit(limit).all()
        except SQLAlchemyError as e:
            logger.error(f"Error searching entities with query '{query}': {e}")
            raise

    def get_by_status(self, session: Session, status: str) -> List[{{service_class}}Entity]:
        """
        Get entities by status.

        Args:
            session: Database session
            status: Entity status

        Returns:
            List of entities with the specified status
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.status == status,
                self.model_class.is_active == True
            ).all()
        except SQLAlchemyError as e:
            logger.error(f"Error getting entities by status '{status}': {e}")
            raise


class {{service_class}}AttributeRepository(BaseRepository[{{service_class}}Attribute]):
    """Repository for {{service_name}} attributes."""

    def __init__(self, db_manager: DatabaseManager):
        super().__init__({{service_class}}Attribute, db_manager)

    def get_by_entity_id(self, session: Session, entity_id: int) -> List[{{service_class}}Attribute]:
        """
        Get all attributes for an entity.

        Args:
            session: Database session
            entity_id: Entity ID

        Returns:
            List of attributes
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.entity_id == entity_id,
                self.model_class.is_active == True
            ).all()
        except SQLAlchemyError as e:
            logger.error(f"Error getting attributes for entity ID {entity_id}: {e}")
            raise

    def get_by_name(self, session: Session, entity_id: int, attribute_name: str) -> Optional[{{service_class}}Attribute]:
        """
        Get specific attribute by name for an entity.

        Args:
            session: Database session
            entity_id: Entity ID
            attribute_name: Attribute name

        Returns:
            Attribute or None if not found
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.entity_id == entity_id,
                self.model_class.attribute_name == attribute_name,
                self.model_class.is_active == True
            ).first()
        except SQLAlchemyError as e:
            logger.error(f"Error getting attribute '{attribute_name}' for entity ID {entity_id}: {e}")
            raise


class AuditLogRepository(BaseRepository[{{service_class}}AuditLog]):
    """Repository for audit logs."""

    def __init__(self, db_manager: DatabaseManager):
        super().__init__({{service_class}}AuditLog, db_manager)

    def log_change(
        self,
        session: Session,
        entity_id: int,
        entity_type: str,
        action: str,
        old_values: Dict[str, Any] = None,
        new_values: Dict[str, Any] = None,
        user_id: str = None,
        session_id: str = None,
        ip_address: str = None,
        user_agent: str = None
    ) -> {{service_class}}AuditLog:
        """
        Log an audit event.

        Args:
            session: Database session
            entity_id: Entity ID
            entity_type: Type of entity
            action: Action performed (CREATE, UPDATE, DELETE)
            old_values: Previous values
            new_values: New values
            user_id: User performing the action
            session_id: Session ID
            ip_address: IP address
            user_agent: User agent string

        Returns:
            Created audit log entry
        """
        try:
            # Calculate changed fields
            changed_fields = []
            if old_values and new_values:
                changed_fields = [
                    field for field in new_values.keys()
                    if old_values.get(field) != new_values.get(field)
                ]

            audit_log = self.create(
                session=session,
                entity_id=entity_id,
                entity_type=entity_type,
                action=action,
                old_values=json.dumps(old_values) if old_values else None,
                new_values=json.dumps(new_values) if new_values else None,
                changed_fields=json.dumps(changed_fields),
                user_id=user_id,
                session_id=session_id,
                ip_address=ip_address,
                user_agent=user_agent
            )

            logger.info(f"Audit log created for {entity_type} ID {entity_id}, action: {action}")
            return audit_log
        except SQLAlchemyError as e:
            logger.error(f"Error creating audit log: {e}")
            raise

    def get_entity_history(self, session: Session, entity_id: int, entity_type: str) -> List[{{service_class}}AuditLog]:
        """
        Get audit history for an entity.

        Args:
            session: Database session
            entity_id: Entity ID
            entity_type: Entity type

        Returns:
            List of audit logs for the entity
        """
        try:
            return session.query(self.model_class).filter(
                self.model_class.entity_id == entity_id,
                self.model_class.entity_type == entity_type
            ).order_by(desc(self.model_class.created_at)).all()
        except SQLAlchemyError as e:
            logger.error(f"Error getting audit history for {entity_type} ID {entity_id}: {e}")
            raise


# Repository instances
_repositories = {}

def setup_repositories(db_manager: DatabaseManager):
    """Setup repository instances."""
    global _repositories
    _repositories = {
        'entity': {{service_class}}EntityRepository(db_manager),
        'attribute': {{service_class}}AttributeRepository(db_manager),
        'audit': AuditLogRepository(db_manager)
    }

def get_entity_repository() -> {{service_class}}EntityRepository:
    """Get entity repository instance."""
    return _repositories['entity']

def get_attribute_repository() -> {{service_class}}AttributeRepository:
    """Get attribute repository instance."""
    return _repositories['attribute']

def get_audit_repository() -> AuditLogRepository:
    """Get audit repository instance."""
    return _repositories['audit']
