"""
RabbitMQ Manager for Message Queue Service
"""

import asyncio
import logging
import json
from typing import Optional, Dict, Any, List, Callable
from datetime import datetime, timezone
import ssl

import aio_pika
from aio_pika import Message as AioPikaMessage, DeliveryMode, ExchangeType
from aio_pika.exceptions import AMQPException

from src.{{service_package}}.app.core.config import {{service_class}}ServiceConfig
from src.{{service_package}}.app.core.models import Message, MessageMetadata

logger = logging.getLogger(__name__)


class RabbitMQManager:
    """Manages RabbitMQ connections and operations."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the RabbitMQ manager."""
        self.config = config
        self.connection: Optional[aio_pika.Connection] = None
        self.channel: Optional[aio_pika.Channel] = None
        self.exchanges: Dict[str, aio_pika.Exchange] = {}
        self.queues: Dict[str, aio_pika.Queue] = {}
        self.is_initialized = False

    async def initialize(self) -> None:
        """Initialize RabbitMQ connections."""
        if not self.config.rabbitmq_enabled:
            logger.warning("RabbitMQ is not enabled")
            return

        try:
            logger.info("Initializing RabbitMQ manager...")

            # Create connection
            await self._create_connection()

            # Create channel
            await self._create_channel()

            # Setup exchanges and queues
            await self._setup_topology()

            self.is_initialized = True
            logger.info("RabbitMQ manager initialized successfully")

        except Exception as e:
            logger.error(f"Failed to initialize RabbitMQ manager: {e}")
            raise

    async def _create_connection(self) -> None:
        """Create RabbitMQ connection."""
        try:
            connection_config = self.config.get_rabbitmq_config()

            # Build connection URL
            url_parts = [
                f"amqp://{connection_config.get('username', 'guest')}:",
                f"{connection_config.get('password', 'guest')}@",
                f"{connection_config.get('host', 'localhost')}:",
                f"{connection_config.get('port', 5672)}/",
                f"{connection_config.get('virtual_host', '/')}"
            ]

            connection_url = "".join(url_parts)

            # SSL configuration if enabled
            ssl_context = None
            if connection_config.get('ssl_enabled', False):
                ssl_context = ssl.create_default_context()
                if not connection_config.get('ssl_verify', True):
                    ssl_context.check_hostname = False
                    ssl_context.verify_mode = ssl.CERT_NONE

            # Create connection
            self.connection = await aio_pika.connect_robust(
                url=connection_url,
                ssl_context=ssl_context,
                heartbeat=connection_config.get('heartbeat', 600),
                blocked_connection_timeout=connection_config.get('blocked_connection_timeout', 300),
                connection_attempts=connection_config.get('connection_attempts', 3),
                retry_delay=connection_config.get('retry_delay', 5)
            )

            logger.info("RabbitMQ connection established")

        except Exception as e:
            logger.error(f"Failed to create RabbitMQ connection: {e}")
            raise

    async def _create_channel(self) -> None:
        """Create RabbitMQ channel."""
        try:
            if not self.connection:
                raise Exception("No RabbitMQ connection available")

            self.channel = await self.connection.channel()

            # Set QoS (prefetch count for fair dispatching)
            await self.channel.set_qos(prefetch_count=self.config.rabbitmq_prefetch_count)

            logger.info("RabbitMQ channel created")

        except Exception as e:
            logger.error(f"Failed to create RabbitMQ channel: {e}")
            raise

    async def _setup_topology(self) -> None:
        """Setup RabbitMQ exchanges and queues."""
        try:
            exchange_configs = self.config.get_exchange_configs()
            queue_configs = self.config.get_queue_configs()

            # Create exchanges
            for exchange_config in exchange_configs:
                exchange = await self._create_exchange(exchange_config)
                self.exchanges[exchange_config["name"]] = exchange

            # Create queues
            for queue_config in queue_configs:
                queue = await self._create_queue(queue_config)
                self.queues[queue_config["name"]] = queue

            # Create bindings
            await self._create_bindings()

            logger.info("RabbitMQ topology setup complete")

        except Exception as e:
            logger.error(f"Failed to setup RabbitMQ topology: {e}")
            raise

    async def _create_exchange(self, config: Dict[str, Any]) -> aio_pika.Exchange:
        """Create a RabbitMQ exchange."""
        try:
            exchange_type = getattr(ExchangeType, config.get("type", "DIRECT").upper())

            exchange = await self.channel.declare_exchange(
                name=config["name"],
                type=exchange_type,
                durable=config.get("durable", True),
                auto_delete=config.get("auto_delete", False),
                arguments=config.get("arguments", {})
            )

            logger.info(f"Created exchange: {config['name']} ({config.get('type', 'direct')})")
            return exchange

        except Exception as e:
            logger.error(f"Failed to create exchange {config['name']}: {e}")
            raise

    async def _create_queue(self, config: Dict[str, Any]) -> aio_pika.Queue:
        """Create a RabbitMQ queue."""
        try:
            queue = await self.channel.declare_queue(
                name=config["name"],
                durable=config.get("durable", True),
                exclusive=config.get("exclusive", False),
                auto_delete=config.get("auto_delete", False),
                arguments=config.get("arguments", {})
            )

            logger.info(f"Created queue: {config['name']}")
            return queue

        except Exception as e:
            logger.error(f"Failed to create queue {config['name']}: {e}")
            raise

    async def _create_bindings(self) -> None:
        """Create queue-exchange bindings."""
        try:
            binding_configs = self.config.get_binding_configs()

            for binding_config in binding_configs:
                queue_name = binding_config["queue"]
                exchange_name = binding_config["exchange"]
                routing_key = binding_config.get("routing_key", "")

                if queue_name in self.queues and exchange_name in self.exchanges:
                    await self.queues[queue_name].bind(
                        exchange=self.exchanges[exchange_name],
                        routing_key=routing_key,
                        arguments=binding_config.get("arguments", {})
                    )

                    logger.info(f"Bound queue {queue_name} to exchange {exchange_name} with key '{routing_key}'")
                else:
                    logger.warning(f"Cannot bind - queue {queue_name} or exchange {exchange_name} not found")

        except Exception as e:
            logger.error(f"Failed to create bindings: {e}")
            raise

    async def publish_message(
        self,
        exchange_name: str,
        message: Message,
        routing_key: str = "",
        mandatory: bool = False,
        immediate: bool = False
    ) -> bool:
        """Publish a message to RabbitMQ exchange.

        Args:
            exchange_name: Exchange name
            message: Message to publish
            routing_key: Routing key for message
            mandatory: Mandatory flag
            immediate: Immediate flag

        Returns:
            True if message was published successfully
        """
        if not self.channel:
            logger.error("RabbitMQ channel not initialized")
            return False

        try:
            # Prepare message payload
            payload = {
                "id": message.id,
                "type": message.type,
                "data": message.data,
                "metadata": {
                    "timestamp": message.metadata.timestamp.isoformat(),
                    "source": message.metadata.source,
                    "version": message.metadata.version,
                    "correlation_id": message.metadata.correlation_id,
                    "causation_id": message.metadata.causation_id,
                    "user_id": message.metadata.user_id,
                    "session_id": message.metadata.session_id,
                    "trace_id": message.metadata.trace_id,
                    "span_id": message.metadata.span_id,
                    "headers": message.metadata.headers,
                    "tags": message.metadata.tags
                }
            }

            # Create AMQP message
            amqp_message = AioPikaMessage(
                body=json.dumps(payload, default=str).encode('utf-8'),
                content_type='application/json',
                delivery_mode=DeliveryMode.PERSISTENT if self.config.default_delivery_guarantee.value != "at_most_once" else DeliveryMode.NOT_PERSISTENT,
                message_id=message.id,
                correlation_id=message.metadata.correlation_id,
                timestamp=datetime.now(timezone.utc),
                headers={
                    "message_type": message.type,
                    "source": message.metadata.source,
                    "version": message.metadata.version,
                    **(message.metadata.headers or {})
                }
            )

            # Get exchange
            if exchange_name in self.exchanges:
                exchange = self.exchanges[exchange_name]
            else:
                # Use default exchange
                exchange = self.channel.default_exchange

            # Publish message
            await exchange.publish(
                message=amqp_message,
                routing_key=routing_key,
                mandatory=mandatory,
                immediate=immediate
            )

            logger.debug(f"Published message {message.id} to exchange {exchange_name} with routing key '{routing_key}'")
            return True

        except Exception as e:
            logger.error(f"Failed to publish message to exchange {exchange_name}: {e}")
            return False

    async def consume_messages(
        self,
        queue_name: str,
        message_handler: Callable[[Message], bool],
        auto_ack: bool = False
    ) -> None:
        """Consume messages from RabbitMQ queue.

        Args:
            queue_name: Queue name to consume from
            message_handler: Function to handle each message
            auto_ack: Whether to auto-acknowledge messages
        """
        try:
            if queue_name not in self.queues:
                raise Exception(f"Queue {queue_name} not found")

            queue = self.queues[queue_name]

            logger.info(f"Starting RabbitMQ message consumption from queue: {queue_name}")

            async with queue.iterator() as queue_iter:
                async for amqp_message in queue_iter:
                    try:
                        # Convert AMQP message to our Message format
                        message = await self._amqp_message_to_message(amqp_message)

                        # Handle the message
                        success = await self._handle_message_with_retry(message, message_handler)

                        if success:
                            if not auto_ack:
                                amqp_message.ack()
                        else:
                            logger.error(f"Failed to process message after retries: {message.id}")

                            if not auto_ack:
                                # Send to DLQ if configured
                                if self.config.dlq_enabled:
                                    await self._send_to_dlq(message, queue_name)
                                    amqp_message.ack()  # Ack the original message
                                else:
                                    amqp_message.reject(requeue=False)

                    except Exception as e:
                        logger.error(f"Error processing AMQP message: {e}")
                        if not auto_ack:
                            amqp_message.reject(requeue=False)
                        continue

        except Exception as e:
            logger.error(f"Error in RabbitMQ message consumption: {e}")
            raise

    async def _amqp_message_to_message(self, amqp_message) -> Message:
        """Convert AMQP message to our Message format."""
        try:
            payload = json.loads(amqp_message.body.decode('utf-8'))

            metadata = MessageMetadata(
                timestamp=datetime.fromisoformat(payload["metadata"]["timestamp"]),
                source=payload["metadata"]["source"],
                version=payload["metadata"]["version"],
                correlation_id=payload["metadata"]["correlation_id"],
                causation_id=payload["metadata"]["causation_id"],
                user_id=payload["metadata"]["user_id"],
                session_id=payload["metadata"]["session_id"],
                trace_id=payload["metadata"]["trace_id"],
                span_id=payload["metadata"]["span_id"],
                headers=payload["metadata"]["headers"],
                tags=payload["metadata"]["tags"]
            )

            return Message(
                id=payload["id"],
                type=payload["type"],
                data=payload["data"],
                metadata=metadata
            )

        except Exception as e:
            logger.error(f"Failed to convert AMQP message: {e}")
            raise

    async def _handle_message_with_retry(
        self,
        message: Message,
        handler: Callable[[Message], bool],
        max_retries: Optional[int] = None
    ) -> bool:
        """Handle message with retry logic."""
        max_retries = max_retries or self.config.message_retry_attempts
        delay = self.config.message_retry_delay_ms / 1000.0

        for attempt in range(max_retries + 1):
            try:
                success = handler(message)
                if success:
                    return True

                if attempt < max_retries:
                    logger.warning(f"Message processing failed, retrying in {delay}s (attempt {attempt + 1}/{max_retries})")
                    await asyncio.sleep(delay)
                    delay = min(delay * self.config.message_retry_backoff_multiplier,
                              self.config.message_max_retry_delay_ms / 1000.0)

            except Exception as e:
                logger.error(f"Error handling message (attempt {attempt + 1}): {e}")
                if attempt < max_retries:
                    await asyncio.sleep(delay)
                    delay = min(delay * self.config.message_retry_backoff_multiplier,
                              self.config.message_max_retry_delay_ms / 1000.0)

        return False

    async def _send_to_dlq(self, message: Message, original_queue: str) -> None:
        """Send message to dead letter queue."""
        if not self.config.dlq_enabled:
            return

        dlq_exchange = f"{original_queue}{self.config.dlq_exchange_suffix}"
        dlq_routing_key = f"{original_queue}{self.config.dlq_routing_key_suffix}"

        # Add DLQ metadata
        message.metadata.headers = message.metadata.headers or {}
        message.metadata.headers.update({
            "original_queue": original_queue,
            "dlq_timestamp": datetime.now(timezone.utc).isoformat(),
            "failure_reason": "max_retries_exceeded"
        })

        await self.publish_message(dlq_exchange, message, dlq_routing_key)
        logger.info(f"Message {message.id} sent to DLQ exchange: {dlq_exchange}")

    async def get_queue_info(self, queue_name: str) -> Dict[str, Any]:
        """Get information about a queue."""
        try:
            if queue_name in self.queues:
                queue = self.queues[queue_name]
                return {
                    "name": queue.name,
                    "message_count": queue.declaration_result.message_count,
                    "consumer_count": queue.declaration_result.consumer_count
                }
            else:
                return {}
        except Exception as e:
            logger.error(f"Failed to get queue info for {queue_name}: {e}")
            return {}

    async def purge_queue(self, queue_name: str) -> int:
        """Purge messages from a queue.

        Returns:
            Number of messages purged
        """
        try:
            if queue_name in self.queues:
                queue = self.queues[queue_name]
                result = await queue.purge()
                logger.info(f"Purged {result} messages from queue {queue_name}")
                return result
            else:
                logger.warning(f"Queue {queue_name} not found")
                return 0
        except Exception as e:
            logger.error(f"Failed to purge queue {queue_name}: {e}")
            return 0

    async def shutdown(self) -> None:
        """Shutdown RabbitMQ connections."""
        logger.info("Shutting down RabbitMQ manager...")

        try:
            # Clear collections
            self.exchanges.clear()
            self.queues.clear()

            # Close channel
            if self.channel and not self.channel.is_closed:
                await self.channel.close()
                logger.debug("Closed RabbitMQ channel")

            # Close connection
            if self.connection and not self.connection.is_closed:
                await self.connection.close()
                logger.debug("Closed RabbitMQ connection")

            self.is_initialized = False
            logger.info("RabbitMQ manager shutdown complete")

        except Exception as e:
            logger.error(f"Error during RabbitMQ shutdown: {e}")


# Global RabbitMQ manager instance
_rabbitmq_manager: Optional[RabbitMQManager] = None


def get_rabbitmq_manager() -> RabbitMQManager:
    """Get the global RabbitMQ manager instance."""
    global _rabbitmq_manager
    if _rabbitmq_manager is None:
        config = {{service_class}}ServiceConfig()
        _rabbitmq_manager = RabbitMQManager(config)
    return _rabbitmq_manager
