"""
Message Consumers for Message Queue Service
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List, Callable, Union
from datetime import datetime, timezone
import inspect

from src.{{service_package}}.app.core.config import {{service_class}}ServiceConfig
from src.{{service_package}}.app.core.models import Message, MessageMetadata, DeliveryGuarantee
from src.{{service_package}}.app.message_queue.kafka_manager import get_kafka_manager
from src.{{service_package}}.app.message_queue.rabbitmq_manager import get_rabbitmq_manager
from src.{{service_package}}.app.message_queue.redis_manager import get_redis_manager

logger = logging.getLogger(__name__)


class MessageHandler:
    """Base message handler interface."""

    def __init__(self, handler_id: str, message_types: List[str] = None):
        """Initialize the message handler.

        Args:
            handler_id: Unique identifier for this handler
            message_types: List of message types this handler can process (None = all types)
        """
        self.handler_id = handler_id
        self.message_types = message_types or []
        self.is_async = False

    def can_handle(self, message: Message) -> bool:
        """Check if this handler can process the given message."""
        if not self.message_types:
            return True  # Handle all message types
        return message.type in self.message_types

    async def handle(self, message: Message) -> bool:
        """Handle a message.

        Args:
            message: Message to process

        Returns:
            True if message was handled successfully
        """
        raise NotImplementedError

    async def handle_error(self, message: Message, error: Exception) -> bool:
        """Handle processing error.

        Args:
            message: Message that failed to process
            error: Exception that occurred

        Returns:
            True if error was handled and message should be acknowledged
        """
        logger.error(f"Handler {self.handler_id} failed to process message {message.id}: {error}")
        return False


class FunctionHandler(MessageHandler):
    """Handler that wraps a function or coroutine."""

    def __init__(
        self,
        handler_id: str,
        handler_func: Union[Callable[[Message], bool], Callable[[Message], Any]],
        message_types: List[str] = None
    ):
        """Initialize the function handler.

        Args:
            handler_id: Unique identifier for this handler
            handler_func: Function or coroutine to handle messages
            message_types: List of message types this handler can process
        """
        super().__init__(handler_id, message_types)
        self.handler_func = handler_func
        self.is_async = inspect.iscoroutinefunction(handler_func)

    async def handle(self, message: Message) -> bool:
        """Handle a message using the wrapped function."""
        try:
            if self.is_async:
                result = await self.handler_func(message)
            else:
                result = self.handler_func(message)

            # Convert result to boolean
            if isinstance(result, bool):
                return result
            else:
                return result is not None

        except Exception as e:
            return await self.handle_error(message, e)


class MessageConsumer:
    """Base message consumer interface."""

    def __init__(self, config: {{service_class}}ServiceConfig, consumer_id: str):
        """Initialize the message consumer."""
        self.config = config
        self.consumer_id = consumer_id
        self.handlers: Dict[str, MessageHandler] = {}
        self.is_running = False
        self._stop_event = asyncio.Event()

    def register_handler(self, handler: MessageHandler) -> None:
        """Register a message handler."""
        self.handlers[handler.handler_id] = handler
        logger.info(f"Registered handler {handler.handler_id} for consumer {self.consumer_id}")

    def unregister_handler(self, handler_id: str) -> None:
        """Unregister a message handler."""
        if handler_id in self.handlers:
            del self.handlers[handler_id]
            logger.info(f"Unregistered handler {handler_id} from consumer {self.consumer_id}")

    async def process_message(self, message: Message) -> bool:
        """Process a message using registered handlers.

        Args:
            message: Message to process

        Returns:
            True if message was processed successfully by at least one handler
        """
        if not self.handlers:
            logger.warning(f"No handlers registered for consumer {self.consumer_id}")
            return False

        # Find handlers that can process this message
        applicable_handlers = [
            handler for handler in self.handlers.values()
            if handler.can_handle(message)
        ]

        if not applicable_handlers:
            logger.warning(f"No handlers can process message type {message.type} in consumer {self.consumer_id}")
            return False

        # Process with all applicable handlers
        results = []
        for handler in applicable_handlers:
            try:
                success = await handler.handle(message)
                results.append(success)

                if success:
                    logger.debug(f"Handler {handler.handler_id} successfully processed message {message.id}")
                else:
                    logger.warning(f"Handler {handler.handler_id} failed to process message {message.id}")

            except Exception as e:
                logger.error(f"Handler {handler.handler_id} raised exception for message {message.id}: {e}")
                results.append(False)

        # Return True if at least one handler succeeded
        return any(results)

    async def start(self) -> None:
        """Start consuming messages."""
        raise NotImplementedError

    async def stop(self) -> None:
        """Stop consuming messages."""
        self.is_running = False
        self._stop_event.set()


class KafkaConsumer(MessageConsumer):
    """Kafka message consumer."""

    def __init__(self, config: {{service_class}}ServiceConfig, consumer_id: str):
        """Initialize the Kafka consumer."""
        super().__init__(config, consumer_id)
        self.kafka_manager = get_kafka_manager()
        self.kafka_consumer = None
        self.topics = []
        self.group_id = None

    def configure(self, topics: List[str], group_id: Optional[str] = None) -> None:
        """Configure the Kafka consumer.

        Args:
            topics: List of topics to subscribe to
            group_id: Consumer group ID (optional)
        """
        self.topics = topics
        self.group_id = group_id or f"{self.consumer_id}_group"

    async def start(self) -> None:
        """Start consuming messages from Kafka topics."""
        if not self.topics:
            raise ValueError("No topics configured for Kafka consumer")

        try:
            logger.info(f"Starting Kafka consumer {self.consumer_id} for topics: {self.topics}")

            # Create Kafka consumer
            self.kafka_consumer = self.kafka_manager.create_consumer(
                topics=self.topics,
                group_id=self.group_id
            )

            self.is_running = True
            self._stop_event.clear()

            # Start consuming messages
            await self.kafka_manager.consume_messages(
                consumer=self.kafka_consumer,
                message_handler=self.process_message,
                batch_size=self.config.kafka_consumer_max_poll_records,
                timeout_ms=self.config.kafka_consumer_poll_timeout_ms
            )

        except Exception as e:
            logger.error(f"Error starting Kafka consumer {self.consumer_id}: {e}")
            raise

    async def stop(self) -> None:
        """Stop the Kafka consumer."""
        logger.info(f"Stopping Kafka consumer {self.consumer_id}")
        await super().stop()

        if self.kafka_consumer:
            try:
                self.kafka_consumer.close()
                logger.debug(f"Closed Kafka consumer {self.consumer_id}")
            except Exception as e:
                logger.error(f"Error closing Kafka consumer {self.consumer_id}: {e}")


class RabbitMQConsumer(MessageConsumer):
    """RabbitMQ message consumer."""

    def __init__(self, config: {{service_class}}ServiceConfig, consumer_id: str):
        """Initialize the RabbitMQ consumer."""
        super().__init__(config, consumer_id)
        self.rabbitmq_manager = get_rabbitmq_manager()
        self.queue_name = None
        self.auto_ack = False

    def configure(self, queue_name: str, auto_ack: bool = False) -> None:
        """Configure the RabbitMQ consumer.

        Args:
            queue_name: Queue to consume from
            auto_ack: Whether to auto-acknowledge messages
        """
        self.queue_name = queue_name
        self.auto_ack = auto_ack

    async def start(self) -> None:
        """Start consuming messages from RabbitMQ queue."""
        if not self.queue_name:
            raise ValueError("No queue configured for RabbitMQ consumer")

        try:
            logger.info(f"Starting RabbitMQ consumer {self.consumer_id} for queue: {self.queue_name}")

            self.is_running = True
            self._stop_event.clear()

            # Start consuming messages
            await self.rabbitmq_manager.consume_messages(
                queue_name=self.queue_name,
                message_handler=self.process_message,
                auto_ack=self.auto_ack
            )

        except Exception as e:
            logger.error(f"Error starting RabbitMQ consumer {self.consumer_id}: {e}")
            raise

    async def stop(self) -> None:
        """Stop the RabbitMQ consumer."""
        logger.info(f"Stopping RabbitMQ consumer {self.consumer_id}")
        await super().stop()


class RedisStreamConsumer(MessageConsumer):
    """Redis stream consumer."""

    def __init__(self, config: {{service_class}}ServiceConfig, consumer_id: str):
        """Initialize the Redis stream consumer."""
        super().__init__(config, consumer_id)
        self.redis_manager = get_redis_manager()
        self.stream_name = None
        self.group_name = None
        self.consumer_name = None
        self.start_id = ">"
        self.batch_size = 10
        self.block_time = 1000

    def configure(
        self,
        stream_name: str,
        group_name: Optional[str] = None,
        consumer_name: Optional[str] = None,
        start_id: str = ">",
        batch_size: int = 10,
        block_time: int = 1000
    ) -> None:
        """Configure the Redis stream consumer.

        Args:
            stream_name: Stream to consume from
            group_name: Consumer group name (optional)
            consumer_name: Consumer name within group (optional)
            start_id: Starting message ID
            batch_size: Maximum messages per read
            block_time: Block time in milliseconds
        """
        self.stream_name = stream_name
        self.group_name = group_name or f"{self.consumer_id}_group"
        self.consumer_name = consumer_name or self.consumer_id
        self.start_id = start_id
        self.batch_size = batch_size
        self.block_time = block_time

    async def start(self) -> None:
        """Start consuming messages from Redis stream."""
        if not self.stream_name:
            raise ValueError("No stream configured for Redis stream consumer")

        try:
            logger.info(f"Starting Redis stream consumer {self.consumer_id} for stream: {self.stream_name}")

            self.is_running = True
            self._stop_event.clear()

            if self.group_name:
                # Use consumer group
                await self.redis_manager.consume_from_stream_group(
                    stream_name=self.stream_name,
                    group_name=self.group_name,
                    consumer_name=self.consumer_name,
                    message_handler=self.process_message,
                    count=self.batch_size,
                    block=self.block_time
                )
            else:
                # Direct stream reading
                await self._consume_direct()

        except Exception as e:
            logger.error(f"Error starting Redis stream consumer {self.consumer_id}: {e}")
            raise

    async def _consume_direct(self) -> None:
        """Consume directly from stream without consumer group."""
        last_id = self.start_id

        while self.is_running:
            try:
                messages = await self.redis_manager.read_from_stream(
                    stream_name=self.stream_name,
                    start_id=last_id,
                    count=self.batch_size,
                    block=self.block_time
                )

                for msg_data in messages:
                    message = msg_data["message"]
                    stream_id = msg_data["stream_id"]

                    await self.process_message(message)
                    last_id = stream_id

                if not messages:
                    await asyncio.sleep(0.1)

            except Exception as e:
                logger.error(f"Error in Redis stream direct consumption: {e}")
                await asyncio.sleep(1)

    async def stop(self) -> None:
        """Stop the Redis stream consumer."""
        logger.info(f"Stopping Redis stream consumer {self.consumer_id}")
        await super().stop()


class RedisPubSubConsumer(MessageConsumer):
    """Redis pub/sub consumer."""

    def __init__(self, config: {{service_class}}ServiceConfig, consumer_id: str):
        """Initialize the Redis pub/sub consumer."""
        super().__init__(config, consumer_id)
        self.redis_manager = get_redis_manager()
        self.channels = []
        self.patterns = False

    def configure(self, channels: List[str], patterns: bool = False) -> None:
        """Configure the Redis pub/sub consumer.

        Args:
            channels: List of channels to subscribe to
            patterns: Whether channels are patterns
        """
        self.channels = channels
        self.patterns = patterns

    async def start(self) -> None:
        """Start consuming messages from Redis channels."""
        if not self.channels:
            raise ValueError("No channels configured for Redis pub/sub consumer")

        try:
            logger.info(f"Starting Redis pub/sub consumer {self.consumer_id} for channels: {self.channels}")

            self.is_running = True
            self._stop_event.clear()

            # Start subscribing to channels
            await self.redis_manager.subscribe_to_channels(
                channels=self.channels,
                message_handler=self._handle_pubsub_message,
                patterns=self.patterns
            )

        except Exception as e:
            logger.error(f"Error starting Redis pub/sub consumer {self.consumer_id}: {e}")
            raise

    async def _handle_pubsub_message(self, channel: str, message: Message) -> bool:
        """Handle pub/sub message by processing with registered handlers."""
        return await self.process_message(message)

    async def stop(self) -> None:
        """Stop the Redis pub/sub consumer."""
        logger.info(f"Stopping Redis pub/sub consumer {self.consumer_id}")
        await super().stop()


class ConsumerManager:
    """Manager for multiple message consumers."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the consumer manager."""
        self.config = config
        self.consumers: Dict[str, MessageConsumer] = {}
        self.running_tasks: Dict[str, asyncio.Task] = {}

    def create_kafka_consumer(
        self,
        consumer_id: str,
        topics: List[str],
        group_id: Optional[str] = None
    ) -> KafkaConsumer:
        """Create and register a Kafka consumer."""
        consumer = KafkaConsumer(self.config, consumer_id)
        consumer.configure(topics=topics, group_id=group_id)
        self.consumers[consumer_id] = consumer
        logger.info(f"Created Kafka consumer: {consumer_id}")
        return consumer

    def create_rabbitmq_consumer(
        self,
        consumer_id: str,
        queue_name: str,
        auto_ack: bool = False
    ) -> RabbitMQConsumer:
        """Create and register a RabbitMQ consumer."""
        consumer = RabbitMQConsumer(self.config, consumer_id)
        consumer.configure(queue_name=queue_name, auto_ack=auto_ack)
        self.consumers[consumer_id] = consumer
        logger.info(f"Created RabbitMQ consumer: {consumer_id}")
        return consumer

    def create_redis_stream_consumer(
        self,
        consumer_id: str,
        stream_name: str,
        group_name: Optional[str] = None,
        consumer_name: Optional[str] = None
    ) -> RedisStreamConsumer:
        """Create and register a Redis stream consumer."""
        consumer = RedisStreamConsumer(self.config, consumer_id)
        consumer.configure(
            stream_name=stream_name,
            group_name=group_name,
            consumer_name=consumer_name
        )
        self.consumers[consumer_id] = consumer
        logger.info(f"Created Redis stream consumer: {consumer_id}")
        return consumer

    def create_redis_pubsub_consumer(
        self,
        consumer_id: str,
        channels: List[str],
        patterns: bool = False
    ) -> RedisPubSubConsumer:
        """Create and register a Redis pub/sub consumer."""
        consumer = RedisPubSubConsumer(self.config, consumer_id)
        consumer.configure(channels=channels, patterns=patterns)
        self.consumers[consumer_id] = consumer
        logger.info(f"Created Redis pub/sub consumer: {consumer_id}")
        return consumer

    async def start_consumer(self, consumer_id: str) -> None:
        """Start a specific consumer."""
        if consumer_id not in self.consumers:
            raise ValueError(f"Consumer {consumer_id} not found")

        if consumer_id in self.running_tasks:
            logger.warning(f"Consumer {consumer_id} is already running")
            return

        consumer = self.consumers[consumer_id]
        task = asyncio.create_task(consumer.start())
        self.running_tasks[consumer_id] = task

        logger.info(f"Started consumer: {consumer_id}")

    async def stop_consumer(self, consumer_id: str) -> None:
        """Stop a specific consumer."""
        if consumer_id not in self.consumers:
            logger.warning(f"Consumer {consumer_id} not found")
            return

        # Stop the consumer
        consumer = self.consumers[consumer_id]
        await consumer.stop()

        # Cancel and cleanup the task
        if consumer_id in self.running_tasks:
            task = self.running_tasks[consumer_id]
            if not task.done():
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass

            del self.running_tasks[consumer_id]

        logger.info(f"Stopped consumer: {consumer_id}")

    async def start_all(self) -> None:
        """Start all registered consumers."""
        for consumer_id in self.consumers:
            await self.start_consumer(consumer_id)

    async def stop_all(self) -> None:
        """Stop all running consumers."""
        tasks = []
        for consumer_id in list(self.running_tasks.keys()):
            tasks.append(self.stop_consumer(consumer_id))

        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)

    def get_consumer(self, consumer_id: str) -> Optional[MessageConsumer]:
        """Get a consumer by ID."""
        return self.consumers.get(consumer_id)

    def list_consumers(self) -> List[str]:
        """List all registered consumer IDs."""
        return list(self.consumers.keys())

    def list_running_consumers(self) -> List[str]:
        """List all currently running consumer IDs."""
        return list(self.running_tasks.keys())


# Global consumer manager instance
_consumer_manager: Optional[ConsumerManager] = None


def get_consumer_manager() -> ConsumerManager:
    """Get the global consumer manager instance."""
    global _consumer_manager
    if _consumer_manager is None:
        config = {{service_class}}ServiceConfig()
        _consumer_manager = ConsumerManager(config)
    return _consumer_manager
