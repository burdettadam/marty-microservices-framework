"""
User Manager for {{service_name}} Authentication Service
"""

import secrets
import uuid
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, List, Tuple
import logging

from src.{{service_package}}.app.core.config import {{service_class}}ServiceConfig
from src.{{service_package}}.app.core.models import User, Role, Permission, UserStatus
from src.{{service_package}}.app.repositories import (
    get_user_repository,
    get_role_repository,
    get_permission_repository,
    get_user_role_repository,
    get_audit_repository
)
from src.{{service_package}}.app.core.auth_manager import get_auth_manager

logger = logging.getLogger(__name__)


class UserManager:
    """Manages user lifecycle, roles, and permissions."""

    def __init__(self, config: {{service_class}}ServiceConfig):
        """Initialize the user manager."""
        self.config = config
        self.user_repo = get_user_repository()
        self.role_repo = get_role_repository()
        self.permission_repo = get_permission_repository()
        self.user_role_repo = get_user_role_repository()
        self.audit_repo = get_audit_repository()
        self.auth_manager = get_auth_manager()

    async def initialize(self) -> None:
        """Initialize the user manager and create default roles."""
        logger.info("User manager initialized")
        # Note: In a real implementation, you might want to create default roles here

    def create_user(
        self,
        session,
        username: str,
        email: str,
        password: Optional[str] = None,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        display_name: Optional[str] = None,
        roles: Optional[List[str]] = None,
        external_id: Optional[str] = None,
        profile_data: Optional[Dict[str, Any]] = None,
        auto_verify_email: bool = False,
        created_by: Optional[str] = None
    ) -> User:
        """Create a new user.

        Args:
            session: Database session
            username: Unique username
            email: User email address
            password: Plain text password (optional for OAuth-only users)
            first_name: User's first name
            last_name: User's last name
            display_name: Display name (auto-generated if not provided)
            roles: List of role names to assign
            external_id: External system identifier
            profile_data: Additional profile information
            auto_verify_email: Whether to auto-verify email
            created_by: ID of user who created this account

        Returns:
            Created User object

        Raises:
            ValueError: If user creation fails validation
        """
        # Check if username or email already exists
        if self.user_repo.get_by_username(session, username):
            raise ValueError(f"Username '{username}' already exists")

        if self.user_repo.get_by_email(session, email):
            raise ValueError(f"Email '{email}' already exists")

        # Validate and hash password if provided
        password_hash = None
        if password:
            is_valid, errors = self.auth_manager.validate_password_strength(password)
            if not is_valid:
                raise ValueError(f"Password validation failed: {', '.join(errors)}")
            password_hash = self.auth_manager.hash_password(password)

        # Generate email verification token if needed
        email_verification_token = None
        email_verification_expires = None
        status = UserStatus.ACTIVE.value if auto_verify_email else UserStatus.PENDING_VERIFICATION.value

        if not auto_verify_email:
            email_verification_token = secrets.token_urlsafe(32)
            email_verification_expires = datetime.now(timezone.utc) + timedelta(hours=24)

        # Create user
        user = self.user_repo.create_user(
            session=session,
            username=username,
            email=email,
            password_hash=password_hash,
            first_name=first_name,
            last_name=last_name,
            display_name=display_name,
            status=status,
            email_verified=auto_verify_email,
            email_verification_token=email_verification_token,
            email_verification_expires=email_verification_expires,
            external_id=external_id,
            profile_data=profile_data
        )

        # Assign roles
        if roles:
            self.assign_user_roles(session, user.id, roles, assigned_by=created_by)
        else:
            # Assign default role if configured
            if self.config.rbac_default_role:
                self.assign_user_roles(session, user.id, [self.config.rbac_default_role], assigned_by=created_by)

        # Check if user should be admin based on email
        if email.lower() in [admin_email.lower() for admin_email in self.config.rbac_admin_emails]:
            self.assign_user_roles(session, user.id, ["admin"], assigned_by=created_by)

        # Log user creation
        self.audit_repo.log_auth_event(
            session=session,
            event_type="user_created",
            event_category="user_management",
            success=True,
            user_id=user.id,
            username=user.username,
            email=user.email,
            details={
                "created_by": created_by,
                "auto_verify_email": auto_verify_email,
                "roles_assigned": roles or [self.config.rbac_default_role] if self.config.rbac_default_role else []
            }
        )

        logger.info(f"Created user {username} with ID {user.id}")
        return user

    def get_user_by_id(self, session, user_id: str) -> Optional[User]:
        """Get user by ID."""
        return self.user_repo.get_by_id(session, user_id)

    def get_user_by_username(self, session, username: str) -> Optional[User]:
        """Get user by username."""
        return self.user_repo.get_by_username(session, username)

    def get_user_by_email(self, session, email: str) -> Optional[User]:
        """Get user by email."""
        return self.user_repo.get_by_email(session, email)

    def update_user(
        self,
        session,
        user_id: str,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        display_name: Optional[str] = None,
        profile_data: Optional[Dict[str, Any]] = None,
        preferences: Optional[Dict[str, Any]] = None,
        timezone: Optional[str] = None,
        locale: Optional[str] = None,
        updated_by: Optional[str] = None
    ) -> Optional[User]:
        """Update user profile information.

        Args:
            session: Database session
            user_id: User ID to update
            first_name: Updated first name
            last_name: Updated last name
            display_name: Updated display name
            profile_data: Updated profile data
            preferences: Updated user preferences
            timezone: Updated timezone
            locale: Updated locale
            updated_by: ID of user making the update

        Returns:
            Updated User object or None if user not found
        """
        user = self.user_repo.get_by_id(session, user_id)
        if not user:
            return None

        # Store old values for audit
        old_values = {
            "first_name": user.first_name,
            "last_name": user.last_name,
            "display_name": user.display_name,
            "timezone": user.timezone,
            "locale": user.locale
        }

        # Update fields
        update_fields = {}
        if first_name is not None:
            update_fields["first_name"] = first_name
        if last_name is not None:
            update_fields["last_name"] = last_name
        if display_name is not None:
            update_fields["display_name"] = display_name
        if profile_data is not None:
            update_fields["profile_data"] = profile_data
        if preferences is not None:
            update_fields["preferences"] = preferences
        if timezone is not None:
            update_fields["timezone"] = timezone
        if locale is not None:
            update_fields["locale"] = locale

        updated_user = self.user_repo.update(session, user_id, **update_fields)

        if updated_user:
            # Log the update
            new_values = {key: getattr(updated_user, key) for key in update_fields.keys()}

            self.audit_repo.log_auth_event(
                session=session,
                event_type="user_updated",
                event_category="user_management",
                success=True,
                user_id=user.id,
                username=user.username,
                details={
                    "updated_by": updated_by,
                    "old_values": old_values,
                    "new_values": new_values
                }
            )

        return updated_user

    def change_user_status(
        self,
        session,
        user_id: str,
        new_status: str,
        reason: Optional[str] = None,
        changed_by: Optional[str] = None
    ) -> bool:
        """Change user account status.

        Args:
            session: Database session
            user_id: User ID
            new_status: New status value
            reason: Reason for status change
            changed_by: ID of user making the change

        Returns:
            True if status was changed successfully
        """
        user = self.user_repo.get_by_id(session, user_id)
        if not user:
            return False

        old_status = user.status
        updated_user = self.user_repo.update(session, user_id, status=new_status)

        if updated_user:
            self.audit_repo.log_auth_event(
                session=session,
                event_type="user_status_changed",
                event_category="user_management",
                success=True,
                user_id=user.id,
                username=user.username,
                details={
                    "changed_by": changed_by,
                    "old_status": old_status,
                    "new_status": new_status,
                    "reason": reason
                }
            )
            return True

        return False

    def delete_user(
        self,
        session,
        user_id: str,
        deleted_by: Optional[str] = None,
        reason: Optional[str] = None
    ) -> bool:
        """Delete a user account.

        Args:
            session: Database session
            user_id: User ID to delete
            deleted_by: ID of user performing deletion
            reason: Reason for deletion

        Returns:
            True if user was deleted successfully
        """
        user = self.user_repo.get_by_id(session, user_id)
        if not user:
            return False

        # Log before deletion
        self.audit_repo.log_auth_event(
            session=session,
            event_type="user_deleted",
            event_category="user_management",
            success=True,
            user_id=user.id,
            username=user.username,
            email=user.email,
            details={
                "deleted_by": deleted_by,
                "reason": reason
            }
        )

        # Delete the user (this will cascade to related records)
        success = self.user_repo.delete(session, user_id)

        if success:
            logger.info(f"Deleted user {user.username} (ID: {user_id})")

        return success

    def assign_user_roles(
        self,
        session,
        user_id: str,
        role_names: List[str],
        assigned_by: Optional[str] = None
    ) -> List[str]:
        """Assign roles to a user.

        Args:
            session: Database session
            user_id: User ID
            role_names: List of role names to assign
            assigned_by: ID of user making the assignment

        Returns:
            List of successfully assigned role names
        """
        assigned_roles = []

        for role_name in role_names:
            role = self.role_repo.get_by_name(session, role_name)
            if not role:
                logger.warning(f"Role '{role_name}' not found")
                continue

            if not role.is_active:
                logger.warning(f"Role '{role_name}' is not active")
                continue

            # Check if user already has this role
            existing_assignment = session.query(self.user_role_repo.model_class).filter(
                self.user_role_repo.model_class.user_id == user_id,
                self.user_role_repo.model_class.role_id == role.id,
                self.user_role_repo.model_class.is_active == True
            ).first()

            if existing_assignment:
                logger.debug(f"User {user_id} already has role '{role_name}'")
                continue

            # Assign the role
            user_role = self.user_role_repo.assign_role(
                session=session,
                user_id=user_id,
                role_id=role.id,
                assigned_by=assigned_by
            )

            assigned_roles.append(role_name)

            # Log role assignment
            self.audit_repo.log_auth_event(
                session=session,
                event_type="role_assigned",
                event_category="authorization",
                success=True,
                user_id=user_id,
                details={
                    "role_name": role_name,
                    "role_id": role.id,
                    "assigned_by": assigned_by
                }
            )

        logger.info(f"Assigned roles {assigned_roles} to user {user_id}")
        return assigned_roles

    def revoke_user_roles(
        self,
        session,
        user_id: str,
        role_names: List[str],
        revoked_by: Optional[str] = None
    ) -> List[str]:
        """Revoke roles from a user.

        Args:
            session: Database session
            user_id: User ID
            role_names: List of role names to revoke
            revoked_by: ID of user making the revocation

        Returns:
            List of successfully revoked role names
        """
        revoked_roles = []

        for role_name in role_names:
            role = self.role_repo.get_by_name(session, role_name)
            if not role:
                logger.warning(f"Role '{role_name}' not found")
                continue

            success = self.user_role_repo.revoke_role(session, user_id, role.id)
            if success:
                revoked_roles.append(role_name)

                # Log role revocation
                self.audit_repo.log_auth_event(
                    session=session,
                    event_type="role_revoked",
                    event_category="authorization",
                    success=True,
                    user_id=user_id,
                    details={
                        "role_name": role_name,
                        "role_id": role.id,
                        "revoked_by": revoked_by
                    }
                )

        logger.info(f"Revoked roles {revoked_roles} from user {user_id}")
        return revoked_roles

    def get_user_roles(self, session, user_id: str) -> List[Role]:
        """Get all roles for a user."""
        return self.role_repo.get_user_roles(session, user_id)

    def get_user_permissions(self, session, user_id: str) -> List[Permission]:
        """Get all permissions for a user through their roles."""
        return self.permission_repo.get_user_permissions(session, user_id)

    def has_permission(self, session, user_id: str, permission_name: str) -> bool:
        """Check if a user has a specific permission.

        Args:
            session: Database session
            user_id: User ID
            permission_name: Permission name to check

        Returns:
            True if user has the permission
        """
        user_permissions = self.get_user_permissions(session, user_id)
        return any(perm.name == permission_name for perm in user_permissions)

    def has_role(self, session, user_id: str, role_name: str) -> bool:
        """Check if a user has a specific role.

        Args:
            session: Database session
            user_id: User ID
            role_name: Role name to check

        Returns:
            True if user has the role
        """
        user_roles = self.get_user_roles(session, user_id)
        return any(role.name == role_name for role in user_roles)

    def search_users(
        self,
        session,
        query: Optional[str] = None,
        status: Optional[str] = None,
        role_name: Optional[str] = None,
        limit: int = 50,
        offset: int = 0
    ) -> List[User]:
        """Search for users.

        Args:
            session: Database session
            query: Search query (username, email, name)
            status: Filter by user status
            role_name: Filter by role name
            limit: Maximum results to return
            offset: Number of results to skip

        Returns:
            List of matching users
        """
        # If filtering by role, we need a more complex query
        if role_name:
            role = self.role_repo.get_by_name(session, role_name)
            if not role:
                return []

            # Get users with the specified role
            from sqlalchemy.orm import aliased
            from sqlalchemy import and_

            UserRole = aliased(self.user_role_repo.model_class)
            query_obj = session.query(User).join(UserRole).filter(
                and_(
                    UserRole.role_id == role.id,
                    UserRole.is_active == True
                )
            )

            if query:
                query_obj = query_obj.filter(
                    or_(
                        User.username.ilike(f"%{query}%"),
                        User.email.ilike(f"%{query}%"),
                        User.first_name.ilike(f"%{query}%"),
                        User.last_name.ilike(f"%{query}%"),
                        User.display_name.ilike(f"%{query}%")
                    )
                )

            if status:
                query_obj = query_obj.filter(User.status == status)

            return query_obj.order_by(User.created_at.desc()).offset(offset).limit(limit).all()

        # Standard search without role filter
        return self.user_repo.search_users(session, query or "", status, limit, offset)

    def verify_email(self, session, verification_token: str) -> bool:
        """Verify a user's email address using verification token.

        Args:
            session: Database session
            verification_token: Email verification token

        Returns:
            True if email was verified successfully
        """
        user = session.query(User).filter(
            User.email_verification_token == verification_token
        ).first()

        if not user:
            return False

        # Check if token is expired
        if user.email_verification_expires and datetime.now(timezone.utc) > user.email_verification_expires:
            return False

        # Verify the email
        success = self.user_repo.verify_email(session, user.id)

        if success:
            self.audit_repo.log_auth_event(
                session=session,
                event_type="email_verified",
                event_category="user_management",
                success=True,
                user_id=user.id,
                username=user.username,
                email=user.email
            )
            logger.info(f"Email verified for user {user.username}")

        return success

    def generate_password_reset_token(self, session, email: str) -> Optional[str]:
        """Generate a password reset token for a user.

        Args:
            session: Database session
            email: User email address

        Returns:
            Password reset token if user found, None otherwise
        """
        user = self.user_repo.get_by_email(session, email)
        if not user:
            return None

        reset_token = secrets.token_urlsafe(32)
        reset_expires = datetime.now(timezone.utc) + timedelta(hours=1)

        self.user_repo.update(
            session,
            user.id,
            password_reset_token=reset_token,
            password_reset_expires=reset_expires
        )

        self.audit_repo.log_auth_event(
            session=session,
            event_type="password_reset_requested",
            event_category="security",
            success=True,
            user_id=user.id,
            username=user.username,
            email=user.email
        )

        logger.info(f"Password reset token generated for user {user.username}")
        return reset_token

    def reset_password(self, session, reset_token: str, new_password: str) -> bool:
        """Reset a user's password using reset token.

        Args:
            session: Database session
            reset_token: Password reset token
            new_password: New password

        Returns:
            True if password was reset successfully
        """
        user = session.query(User).filter(
            User.password_reset_token == reset_token
        ).first()

        if not user:
            return False

        # Check if token is expired
        if user.password_reset_expires and datetime.now(timezone.utc) > user.password_reset_expires:
            return False

        # Validate new password
        is_valid, errors = self.auth_manager.validate_password_strength(new_password)
        if not is_valid:
            raise ValueError(f"Password validation failed: {', '.join(errors)}")

        # Hash and update password
        password_hash = self.auth_manager.hash_password(new_password)

        self.user_repo.update(
            session,
            user.id,
            password_hash=password_hash,
            password_reset_token=None,
            password_reset_expires=None,
            password_changed_at=datetime.now(timezone.utc),
            must_change_password=False
        )

        self.audit_repo.log_auth_event(
            session=session,
            event_type="password_reset_completed",
            event_category="security",
            success=True,
            user_id=user.id,
            username=user.username,
            email=user.email
        )

        logger.info(f"Password reset completed for user {user.username}")
        return True


# Global user manager instance
_user_manager: Optional[UserManager] = None


def get_user_manager() -> UserManager:
    """Get the global user manager instance."""
    global _user_manager
    if _user_manager is None:
        config = {{service_class}}ServiceConfig()
        _user_manager = UserManager(config)
    return _user_manager
